<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Kamuy - AI Image Editor</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    @import url('https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css');

    :root {
      --bg-primary: #f9fafb;
      --bg-secondary: #ffffff;
      --text-primary: #111827;
      --text-secondary: #4b5563;
      --border-primary: #e5e7eb;
      --btn-bg: #3b82f6;
      --btn-text: #ffffff;
      --tab-active: #2563eb;
      --tab-inactive: #e5e7eb;
    }

    .dark {
      --bg-primary: #111827;
      --bg-secondary: #1f2937;
      --text-primary: #f9fafb;
      --text-secondary: #d1d5db;
      --border-primary: #374151;
      --btn-bg: #2563eb;
      --btn-text: #ffffff;
      --tab-active: #3b82f6;
      --tab-inactive: #4b5563;
    }

    body {
      font-family: 'Inter', sans-serif;
      background-color: var(--bg-primary);
      color: var(--text-primary);
      transition: background-color 0.3s ease, color 0.3s ease;
      touch-action: manipulation;
    }

    .container {
      background-color: var(--bg-secondary);
      border-radius: 0.75rem;
      box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
      overflow: hidden;
    }

    /* Tab styles */
    .tabs-container {
      display: flex;
      border-bottom: 1px solid var(--border-primary);
    }
    
    .tab {
      flex: 1;
      text-align: center;
      padding: 0.75rem 0;
      cursor: pointer;
      transition: all 0.3s ease;
      position: relative;
      font-weight: 500;
      color: var(--text-secondary);
    }
    
    .tab.active {
      color: var(--tab-active);
    }
    
    .tab.active::after {
      content: '';
      position: absolute;
      bottom: -1px;
      left: 0;
      width: 100%;
      height: 3px;
      background-color: var(--tab-active);
    }
    
    .tab:hover:not(.active) {
      background-color: rgba(37, 99, 235, 0.05);
    }
    
    .tab-content {
      display: none;
      animation: fadeIn 0.3s ease;
    }
    
    .tab-content.active {
      display: block;
    }
    
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(5px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .dropzone {
      border: 3px dashed var(--border-primary);
      border-radius: 12px;
      background: #f8f9fa;
      transition: all 0.2s ease;
      color: var(--text-secondary);
    }

    .dark .dropzone {
      background: #1f2937;
      color: #d1d5db;
    }

    .dropzone:hover {
      border-color: #0d6efd;
      background: #f1f3f5;
    }

    .dark .dropzone:hover {
      background: #374151;
    }

    .spinner {
      display: inline-block;
      width: 1em;
      height: 1em;
      border: 2px solid #f3f3f3;
      border-top: 2px solid #fff;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    .style-btn {
      @apply px-3 py-1 text-xs font-medium rounded-full border transition-all duration-200 cursor-pointer relative;
      border-color: var(--border-primary);
      color: var(--text-primary);
      background-color: transparent;
    }

    .style-btn:hover {
      background-color: #2563eb;
      color: white;
      transform: scale(1.05);
    }

    .style-btn.style-active {
      background-color: #2563eb;
      color: white;
    }

    .tooltip {
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%);
      background: #1f2937;
      color: white;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 0.75rem;
      white-space: nowrap;
      z-index: 10;
      opacity: 0;
      visibility: hidden;
      transition: all 0.2s ease;
      margin-bottom: 4px;
    }

    .style-btn:hover .tooltip {
      opacity: 1;
      visibility: visible;
    }

    .style-grid {
      display: grid;
      grid-template-columns: repeat(5, 1fr);
      gap: 0.5rem;
    }

    .toast {
      position: fixed;
      top: 20px;
      right: 20px;
      max-width: 300px;
      padding: 12px 16px;
      border-radius: 8px;
      background: #1f2937;
      color: white;
      font-size: 0.875rem;
      box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
      transform: translateX(120%);
      opacity: 0;
      transition: all 0.3s ease;
      z-index: 50;
    }

    .toast.show {
      transform: translateX(0);
      opacity: 1;
    }

    /* Loading Screen */
    .loading-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 1rem;
    }

    .loading-progress {
      width: 100%;
      height: 8px;
      background-color: #e5e7eb;
      border-radius: 4px;
      overflow: hidden;
      margin: 1rem 0;
    }

    .progress-bar {
      height: 100%;
      width: 0%;
      background-color: #2563eb;
      transition: width 0.3s ease;
    }

    .loading-text {
      font-size: 1.1rem;
      font-weight: 500;
      color: var(--text-primary);
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    @media (max-width: 640px) {
      .style-grid {
        grid-template-columns: repeat(3, 1fr);
      }
      .dropzone {
        padding: 1rem;
      }
      .spinner {
        width: 1.2em;
        height: 1.2em;
      }
    }

    /* Vertical Reveal Slider */
    .comparison-container {
      position: relative;
      width: 100%;
      height: auto;
      overflow: hidden;
      border-radius: 0.5rem;
      border: 1px solid var(--border-primary);
      touch-action: none;
    }

    .comparison-image {
      display: block;
      width: 100%;
      height: auto;
    }

    .image-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      pointer-events: none;
    }

    .image-overlay img {
      width: 100%;
      height: auto;
    }

    .slider-handle {
      position: absolute;
      top: 0;
      left: 50%;
      width: 40px;
      height: 100%;
      cursor: ew-resize;
      z-index: 3;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(255,255,255,0.8);
      border-left: 1px solid #d1d5db;
      border-right: 1px solid #d1d5db;
      touch-action: none;
    }

    .dark .slider-handle {
      background: rgba(0,0,0,0.8);
      border-left: 1px solid #374151;
      border-right: 1px solid #374151;
    }

    .slider-handle::before {
      content: "↔";
      font-size: 24px;
      color: #4b5563;
      opacity: 0.8;
    }

    .dark .slider-handle::before {
      color: #d1d5db;
    }

    .slider-instruction {
      text-align: center;
      font-size: 0.875rem;
      color: var(--text-secondary);
      margin-top: 0.25rem;
      font-style: italic;
    }

    /* History Panel */
    .history-panel {
      position: fixed;
      top: 0;
      right: -320px;
      width: 300px;
      height: 100%;
      background: var(--bg-secondary);
      border-left: 1px solid var(--border-primary);
      box-shadow: -4px 0 6px -2px rgba(0,0,0,0.1);
      z-index: 40;
      transition: right 0.3s ease;
      overflow-y: auto;
      padding: 1rem;
    }

    .history-panel.open {
      right: 0;
    }

    .history-item {
      border: 1px solid var(--border-primary);
      border-radius: 8px;
      padding: 0.5rem;
      margin-bottom: 0.5rem;
      cursor: pointer;
    }

    .history-item img {
      width: 100%;
      border-radius: 4px;
      margin-bottom: 0.25rem;
    }

    .history-prompt {
      font-size: 0.75rem;
      color: var(--text-secondary);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .close-history {
      position: absolute;
      top: 10px;
      right: 10px;
      font-size: 1.5rem;
      color: var(--text-secondary);
      cursor: pointer;
    }

    .open-history {
      position: fixed;
      bottom: 20px;
      right: 20px;
      width: 50px;
      height: 50px;
      background: var(--btn-bg);
      color: var(--btn-text);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 4px 6px -1px rgba(0,0,0,0.1);
      z-index: 30;
      cursor: pointer;
    }

    .dark .open-history {
      background: #2563eb;
    }
    
    /* Facebook WebView Warning */
    .fb-warning {
      display: none;
      background-color: #fff1e6;
      border: 1px solid #fed7aa;
      border-radius: 0.5rem;
      padding: 1rem;
      margin-top: 1rem;
      color: #7c2d12;
    }
    
    /* Mask Editor */
    .mask-container {
      position: relative;
      width: 100%;
      margin-top: 1rem;
    }
    
    .mask-canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      cursor: crosshair;
    }
    
    .mask-controls {
      display: flex;
      gap: 0.5rem;
      margin-top: 0.5rem;
      flex-wrap: wrap;
    }
    
    .mask-tool {
      padding: 0.25rem 0.5rem;
      border-radius: 4px;
      background-color: #e5e7eb;
      cursor: pointer;
      font-size: 0.875rem;
      transition: all 0.2s ease;
    }
    
    .mask-tool.active {
      background-color: #2563eb;
      color: white;
    }
    
    .mask-brush-size {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    
    .brush-size-preview {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background-color: #2563eb;
      transition: all 0.2s ease;
    }
    
    .mask-help {
      font-size: 0.75rem;
      color: #6b7280;
      margin-top: 0.5rem;
      text-align: center;
    }
    
    /* Style Transfer Enhancements */
    .style-intensity {
      margin-top: 0.5rem;
    }
    
    .style-intensity label {
      display: block;
      margin-bottom: 0.25rem;
      font-size: 0.875rem;
    }
    
    .intensity-slider {
      width: 100%;
      height: 4px;
      -webkit-appearance: none;
      appearance: none;
      background: #e5e7eb;
      border-radius: 2px;
      outline: none;
    }
    
    .intensity-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: #2563eb;
      cursor: pointer;
    }
    
    .intensity-value {
      text-align: center;
      margin-top: 0.25rem;
      font-size: 0.875rem;
      color: #6b7280;
    }
    
    /* Mask overlay for visual feedback */
    .mask-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 2;
    }
  </style>
</head>
<body class="bg-gray-50 min-h-screen flex items-center justify-center p-4 sm:p-6">
  <div class="w-full max-w-2xl mx-auto container" id="appContainer">
    <div class="p-6 sm:p-8">
      <div class="flex justify-between items-center mb-6">
        <h1 class="text-3xl font-bold text-center">✨ Kamuy</h1>
        <button id="darkModeToggle" class="px-3 py-1 bg-gray-200 dark:bg-gray-700 rounded-lg text-sm">
          Dark Mode
        </button>
      </div>
      
      <!-- Tab Navigation -->
      <div class="tabs-container mb-6">
        <div class="tab active" data-tab="promptEdit">Prompt Edit</div>
        <div class="tab" data-tab="maskEdit">Remove/Add Mask</div>
        <div class="tab" data-tab="styleTransfer">Style Transfer</div>
      </div>
      
      <!-- Tab Content -->
      <div id="promptEditTab" class="tab-content active">
        <p class="text-center mb-6 text-sm text-gray-500">Describe what you want changed - our AI understands natural language</p>
        
        <!-- Upload -->
        <div class="mb-6">
          <label class="block text-sm font-medium mb-2">Upload Image</label>
          <input type="file" id="imageInput" accept="image/*" class="hidden" />
          <div id="dropzone" class="dropzone w-full p-6 text-center cursor-pointer">
            <svg class="mx-auto h-12 w-12 text-gray-400" stroke="currentColor" fill="none" viewBox="0 0 48 48">
              <path d="M28 8H12a4 4 0 00-4 4v20m32-20a4 4 0 014 4v20M16 16l16 16m-16 0l16-16" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
            <p class="mt-2">Click to upload or drag and drop</p>
            <p class="text-xs">PNG, JPG, GIF up to 8MB (smart compression applied)</p>
          </div>
          <!-- Preview -->
          <div id="imagePreview" class="hidden mt-4 p-2 border rounded-lg bg-gray-50 flex items-center">
            <img id="previewImg" class="h-20 w-20 object-cover rounded" />
            <div class="ml-3">
              <p id="previewName" class="text-sm font-medium"></p>
              <p id="previewSize" class="text-sm"></p>
            </div>
          </div>
        </div>

        <!-- Prompt -->
        <div class="mb-6">
          <label for="prompt" class="block text-sm font-medium mb-2">Edit Prompt</label>
          <input type="text" id="prompt" placeholder="Change the car color to red" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500"/>
        </div>

        <!-- Edit Button -->
        <button id="editBtn" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-semibold py-3 px-4 rounded-lg transition duration-200 flex items-center justify-center">
          <i class="fas fa-magic mr-2"></i> Edit Image
        </button>
      </div>
      
      <div id="maskEditTab" class="tab-content">
        <p class="text-center mb-6 text-sm text-gray-500">Paint what to keep or remove - precise object editing</p>
        
        <!-- Upload -->
        <div class="mb-6">
          <label class="block text-sm font-medium mb-2">Upload Image</label>
          <input type="file" id="maskImageInput" accept="image/*" class="hidden" />
          <div id="maskDropzone" class="dropzone w-full p-6 text-center cursor-pointer">
            <svg class="mx-auto h-12 w-12 text-gray-400" stroke="currentColor" fill="none" viewBox="0 0 48 48">
              <path d="M28 8H12a4 4 0 00-4 4v20m32-20a4 4 0 014 4v20M16 16l16 16m-16 0l16-16" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
            <p class="mt-2">Click to upload or drag and drop</p>
            <p class="text-xs">PNG, JPG, GIF up to 8MB (smart compression applied)</p>
          </div>
          <!-- Preview -->
          <div id="maskImagePreview" class="hidden mt-4 p-2 border rounded-lg bg-gray-50 flex items-center">
            <img id="maskPreviewImg" class="h-20 w-20 object-cover rounded" />
            <div class="ml-3">
              <p id="maskPreviewName" class="text-sm font-medium"></p>
              <p id="maskPreviewSize" class="text-sm"></p>
            </div>
          </div>
        </div>
        
        <!-- Mask Editor -->
        <div id="maskEditor" class="hidden mb-6">
          <div class="mask-container" style="position: relative; padding-top: 100%;">
            <img id="maskBaseImage" class="comparison-image" src="" alt="Base image for masking" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: contain;" />
            <canvas id="maskCanvas" class="mask-canvas" width="400" height="400"></canvas>
            <div id="maskOverlay" class="mask-overlay"></div>
          </div>
          
          <div class="mask-controls">
            <div class="mask-tool active" data-tool="brush">🖌️ Brush (Keep)</div>
            <div class="mask-tool" data-tool="eraser">🧹 Eraser (Remove)</div>
            <div class="mask-tool" data-tool="undo">↩️ Undo</div>
            <div class="mask-tool" data-tool="redo">↪️ Redo</div>
            
            <div class="mask-brush-size">
              <label for="brushSize">Size:</label>
              <input type="range" id="brushSize" min="1" max="50" value="10" class="w-24" />
              <div class="brush-size-preview" style="width: 10px; height: 10px;"></div>
            </div>
          </div>
          
          <div class="mask-help">
            <p>Draw on the image to select what to keep (blue) or remove (red)</p>
          </div>
        </div>
        
        <!-- Mask Prompt -->
        <div class="mb-6">
          <label for="maskPrompt" class="block text-sm font-medium mb-2">What would you like to change?</label>
          <input type="text" id="maskPrompt" placeholder="Remove the background" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500"/>
        </div>
        
        <!-- Edit Button -->
        <button id="maskEditBtn" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-semibold py-3 px-4 rounded-lg transition duration-200 flex items-center justify-center">
          <i class="fas fa-paint-brush mr-2"></i> Apply Mask Edit
        </button>
      </div>
      
      <div id="styleTransferTab" class="tab-content">
        <p class="text-center mb-6 text-sm text-gray-500">Transform your image into any artistic style</p>
        
        <!-- Upload -->
        <div class="mb-6">
          <label class="block text-sm font-medium mb-2">Upload Image</label>
          <input type="file" id="styleImageInput" accept="image/*" class="hidden" />
          <div id="styleDropzone" class="dropzone w-full p-6 text-center cursor-pointer">
            <svg class="mx-auto h-12 w-12 text-gray-400" stroke="currentColor" fill="none" viewBox="0 0 48 48">
              <path d="M28 8H12a4 4 0 00-4 4v20m32-20a4 4 0 014 4v20M16 16l16 16m-16 0l16-16" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
            <p class="mt-2">Click to upload or drag and drop</p>
            <p class="text-xs">PNG, JPG, GIF up to 8MB (smart compression applied)</p>
          </div>
          <!-- Preview -->
          <div id="styleImagePreview" class="hidden mt-4 p-2 border rounded-lg bg-gray-50 flex items-center">
            <img id="stylePreviewImg" class="h-20 w-20 object-cover rounded" />
            <div class="ml-3">
              <p id="stylePreviewName" class="text-sm font-medium"></p>
              <p id="stylePreviewSize" class="text-sm"></p>
            </div>
          </div>
        </div>

        <!-- Style Presets -->
        <div class="mb-6">
          <label class="block text-sm font-medium mb-2">Style Presets</label>
          <div class="style-grid" id="styleTransferGrid">
            <button type="button" class="style-btn">
              🎨 Anime
              <span class="tooltip">Transform into vibrant anime style</span>
            </button>
            <button type="button" class="style-btn">
              🎬 Ghibli
              <span class="tooltip">Studio Ghibli watercolor aesthetic</span>
            </button>
            <button type="button" class="style-btn">
              🎨 Picasso
              <span class="tooltip">Cubist abstraction and bold forms</span>
            </button>
            <button type="button" class="style-btn">
              🕹️ Cyberpunk
              <span class="tooltip">Neon lights, rain, futuristic</span>
            </button>
            <button type="button" class="style-btn">
              🖼️ Van Gogh
              <span class="tooltip">Expressive brushstrokes, textured</span>
            </button>
            <button type="button" class="style-btn">
              🧱 LEGO
              <span class="tooltip">Plastic brick diorama style</span>
            </button>
            <button type="button" class="style-btn">
              🎮 Pixel
              <span class="tooltip">16-bit retro video game style</span>
            </button>
            <button type="button" class="style-btn">
              🖋️ Sketch
              <span class="tooltip">Pencil drawing with shading</span>
            </button>
            <button type="button" class="style-btn">
              🧸 Pixar
              <span class="tooltip">3D animation, soft lighting</span>
            </button>
            <button type="button" class="style-btn">
              🏜️ Mirage
              <span class="tooltip">Heat haze, desert illusion</span>
            </button>
          </div>
          
          <!-- Style Intensity Slider -->
          <div class="style-intensity mt-4">
            <label for="styleIntensity">Style Intensity</label>
            <input type="range" id="styleIntensity" class="intensity-slider" min="0.1" max="1.0" step="0.1" value="0.7">
            <div class="intensity-value">Intensity: <span id="intensityValue">70%</span></div>
          </div>
        </div>

        <!-- Edit Button -->
        <button id="styleEditBtn" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-semibold py-3 px-4 rounded-lg transition duration-200 flex items-center justify-center">
          <i class="fas fa-palette mr-2"></i> Apply Style
        </button>
      </div>

      <!-- Loading -->
      <div id="loading" class="hidden mt-4 text-center text-gray-600">
        <div class="loading-container">
          <div class="loading-text">Processing: <span id="progressPercent">0</span>%</div>
          <div class="loading-progress">
            <div class="progress-bar" id="progressBar"></div>
          </div>
        </div>
      </div>

      <!-- Result -->
      <div id="result" class="hidden mt-6">
        <h3 class="text-lg font-medium mb-2">✨ Edited Image</h3>
        <div class="comparison-container relative">
          <img id="beforeImage" class="comparison-image" src="" alt="Original" />
          <div class="image-overlay" id="imageOverlay">
            <img id="afterImage" class="comparison-image" src="" alt="Edited" />
          </div>
          <div class="slider-handle" id="sliderHandle"></div>
        </div>
        <p class="slider-instruction">Drag left/right to compare before/after</p>

        <!-- Download Button -->
        <button id="downloadBtn" class="mt-3 w-full bg-green-600 hover:bg-green-700 text-white font-semibold py-2 px-4 rounded-lg transition duration-200">
          <i class="fas fa-download mr-2"></i> Download Image
        </button>
        <p id="downloadInstructions" class="download-instructions"></p>
      </div>
    </div>
  </div>

  <!-- Toast Notification -->
  <div id="toast" class="toast">Image uploaded successfully</div>

  <!-- History Panel -->
  <div id="historyPanel" class="history-panel">
    <h3 class="text-lg font-semibold mb-4">Recent Edits</h3>
    <div id="historyList"></div>
    <div class="close-history" id="closeHistory">&times;</div>
  </div>

  <!-- Open History Button -->
  <div id="openHistory" class="open-history">
    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path>
    </svg>
  </div>

  <script>
    // Tab state management
    const tabStates = {
      promptEdit: {
        imageFile: null,
        imageUrl: null,
        editedImageUrl: null,
        prompt: '',
        loading: false,
        progress: 0
      },
      maskEdit: {
        imageFile: null,
        imageUrl: null,
        editedImageUrl: null,
        maskData: null,
        prompt: '',
        loading: false,
        progress: 0
      },
      styleTransfer: {
        imageFile: null,
        imageUrl: null,
        editedImageUrl: null,
        styles: [],
        intensity: 0.7,
        loading: false,
        progress: 0
      }
    };
    
    let currentTab = 'promptEdit';
    let maskCanvas = null;
    let maskCtx = null;
    
    // Style placeholders
    const stylePlaceholders = {
      anime: "Make it anime-style with vibrant colors",
      'studio ghibli': "Transform into a Studio Ghibli scene",
      picasso: "in Picasso's cubist style, abstract forms",
      cyberpunk: "Cyberpunk neon lights and rain effects",
      'van gogh': "in the style of Van Gogh, expressive brushstrokes",
      lego: "as a LEGO diorama, plastic texture",
      'pixel art': "in 16-bit pixel art style",
      sketch: "as a pencil sketch, hand-drawn lines",
      pixar: "in Pixar 3D animation style, soft lighting",
      'desert mirage': "with desert mirage effect, heat haze"
    };
    
    // Initialize the app when DOM is ready
    document.addEventListener('DOMContentLoaded', function() {
      // DOM elements
      const tabs = document.querySelectorAll('.tab');
      const tabContents = document.querySelectorAll('.tab-content');
      const toast = document.getElementById('toast');
      
      // Initialize tab state based on current tab
      function initTabState() {
        const state = tabStates[currentTab];
        
        // Reset UI elements
        resetUI();
        
        // Handle Prompt Edit tab
        if (currentTab === 'promptEdit') {
          const imageInput = document.getElementById("imageInput");
          const dropzone = document.getElementById("dropzone");
          const imagePreview = document.getElementById("imagePreview");
          const previewImg = document.getElementById("previewImg");
          const previewName = document.getElementById("previewName");
          const previewSize = document.getElementById("previewSize");
          const promptInput = document.getElementById("prompt");
          const editBtn = document.getElementById("editBtn");
          
          // Restore image preview if exists
          if (state.imageUrl && imagePreview && previewImg) {
            previewImg.src = state.imageUrl;
            if (previewName) previewName.textContent = state.imageFile ? state.imageFile.name : 'Uploaded image';
            if (previewSize) previewSize.textContent = state.imageFile ? (state.imageFile.size / (1024*1024)).toFixed(1) + " MB" : '';
            imagePreview.classList.remove("hidden");
          } else {
            if (imagePreview) imagePreview.classList.add("hidden");
          }
          
          // Restore prompt
          if (promptInput) {
            promptInput.value = state.prompt;
          }
          
          // Restore result if exists
          if (state.editedImageUrl) {
            showResult(state.editedImageUrl);
          }
          
          // Set up events
          if (dropzone && imageInput) {
            dropzone.addEventListener("click", () => {
              // Clear previous file input to allow re-uploading the same file
              imageInput.value = '';
              imageInput.click();
            });
            dropzone.addEventListener("dragover", (e) => {
              e.preventDefault();
              dropzone.classList.add("border-blue-500", "bg-blue-50");
            });
            dropzone.addEventListener("dragleave", () => {
              dropzone.classList.remove("border-blue-500", "bg-blue-50");
            });
            dropzone.addEventListener("drop", (e) => {
              e.preventDefault();
              dropzone.classList.remove("border-blue-500", "bg-blue-50");
              if (e.dataTransfer.files.length) {
                const file = e.dataTransfer.files[0];
                handleImageUpload(file, 'prompt');
              }
            });
            
            imageInput.addEventListener("change", (e) => {
              // Prevent double event triggering
              e.stopPropagation();
              e.preventDefault();
              
              const file = imageInput.files[0];
              if (file) {
                handleImageUpload(file, 'prompt');
              }
            });
          }
          
          // Edit button
          if (editBtn) {
            editBtn.addEventListener("click", async () => {
              const prompt = promptInput ? promptInput.value.trim() : '';
              
              if (!state.imageFile || !prompt) {
                alert("Please upload an image and enter a prompt.");
                return;
              }
              
              state.prompt = prompt;
              state.loading = true;
              state.progress = 0;
              updateLoadingState();
              
              try {
                if (editBtn) editBtn.classList.add("hidden");
                const loading = document.getElementById("loading");
                if (loading) loading.classList.remove("hidden");
                const resultDiv = document.getElementById("result");
                if (resultDiv) resultDiv.classList.add("hidden");
                
                // Start processing
                startProcessing(0, 100);
                
                // Compress and process the image
                const compressionResult = await compressForServer(state.imageFile);
                const compressedFile = compressionResult.file;
                
                // Show compression info
                const originalMB = (state.imageFile.size / (1024*1024)).toFixed(1);
                const compressedMB = (compressionResult.compressedSize / (1024*1024)).toFixed(1);
                const qualityMsg = `Optimized from ${originalMB}MB to ${compressedMB}MB (${compressionResult.dimensions})`;
                showToast(qualityMsg);
                
                // Convert to base64
                const base64Image = await fileToBase64(compressedFile);
                
                // API call
                const response = await fetch("/api/edit", {
                  method: "POST",
                  headers: { 
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                  },
                  body: JSON.stringify({
                    image: base64Image,
                    imageName: state.imageFile.name,
                    imageType: state.imageFile.type,
                    prompt: prompt
                  })
                });
                
                // Stop processing
                stopProcessing();
                
                // Error handling
                if (!response.ok) {
                  let errorMessage = `Server error: ${response.status}`;
                  try {
                    const errorData = await response.json();
                    if (errorData.error) {
                      errorMessage += ` - ${errorData.error}`;
                    }
                  } catch (e) {
                    // Ignore
                  }
                  throw new Error(errorMessage);
                }
                
                // Parse response
                const contentType = response.headers.get("content-type");
                let data;
                if (contentType && contentType.includes("application/json")) {
                  data = await response.json();
                } else {
                  throw new Error("Expected JSON response but received different content type");
                }
                
                if (data.edited_image_url) {
                  // Store edited image URL in tab state
                  state.editedImageUrl = data.edited_image_url;
                  state.loading = false;
                  updateLoadingState();
                  
                  showResult(data.edited_image_url);
                } else {
                  throw new Error("Invalid response format: missing edited_image_url");
                }
              } catch (err) {
                console.error("Detailed error:", err);
                // Stop processing on error
                stopProcessing();
                state.loading = false;
                updateLoadingState();
                
                const loading = document.getElementById("loading");
                if (loading) loading.classList.add("hidden");
                if (editBtn) editBtn.classList.remove("hidden");
                alert("Error: " + err.message);
              }
            });
          }
        }
        
        // Handle Mask Edit tab
        else if (currentTab === 'maskEdit') {
          const maskImageInput = document.getElementById("maskImageInput");
          const maskDropzone = document.getElementById("maskDropzone");
          const maskImagePreview = document.getElementById("maskImagePreview");
          const maskPreviewImg = document.getElementById("maskPreviewImg");
          const maskPreviewName = document.getElementById("maskPreviewName");
          const maskPreviewSize = document.getElementById("maskPreviewSize");
          const maskPromptInput = document.getElementById("maskPrompt");
          const maskEditBtn = document.getElementById("maskEditBtn");
          
          // Restore image preview if exists
          if (state.imageUrl && maskImagePreview && maskPreviewImg) {
            maskPreviewImg.src = state.imageUrl;
            if (maskPreviewName) maskPreviewName.textContent = state.imageFile ? state.imageFile.name : 'Uploaded image';
            if (maskPreviewSize) maskPreviewSize.textContent = state.imageFile ? (state.imageFile.size / (1024*1024)).toFixed(1) + " MB" : '';
            maskImagePreview.classList.remove("hidden");
          } else {
            if (maskImagePreview) maskImagePreview.classList.add("hidden");
          }
          
          // Restore mask editor if image exists
          if (state.imageUrl) {
            initMaskEditor();
          }
          
          // Restore prompt
          if (maskPromptInput) {
            maskPromptInput.value = state.prompt;
          }
          
          // Restore result if exists
          if (state.editedImageUrl) {
            showResult(state.editedImageUrl);
          }
          
          // Set up events
          if (maskDropzone && maskImageInput) {
            maskDropzone.addEventListener("click", () => {
              // Clear previous file input to allow re-uploading the same file
              maskImageInput.value = '';
              maskImageInput.click();
            });
            maskDropzone.addEventListener("dragover", (e) => {
              e.preventDefault();
              maskDropzone.classList.add("border-blue-500", "bg-blue-50");
            });
            maskDropzone.addEventListener("dragleave", () => {
              maskDropzone.classList.remove("border-blue-500", "bg-blue-50");
            });
            maskDropzone.addEventListener("drop", (e) => {
              e.preventDefault();
              maskDropzone.classList.remove("border-blue-500", "bg-blue-50");
              if (e.dataTransfer.files.length) {
                const file = e.dataTransfer.files[0];
                handleImageUpload(file, 'mask');
              }
            });
            
            maskImageInput.addEventListener("change", (e) => {
              // Prevent double event triggering
              e.stopPropagation();
              e.preventDefault();
              
              const file = maskImageInput.files[0];
              if (file) {
                handleImageUpload(file, 'mask');
              }
            });
          }
          
          // Mask Edit button
          if (maskEditBtn) {
            maskEditBtn.addEventListener("click", async () => {
              const prompt = maskPromptInput ? maskPromptInput.value.trim() : '';
              
              if (!state.imageFile) {
                alert("Please upload an image first.");
                return;
              }
              
              // Get mask data
              const maskData = getMaskData();
              if (!maskData) {
                alert("Please draw on the image to select areas to keep/remove.");
                return;
              }
              
              // Prompt is required for mask editing (to describe what to put in the masked area)
              if (!prompt) {
                alert("Please enter a prompt describing what to change in the masked area.");
                return;
              }
              
              state.prompt = prompt;
              state.loading = true;
              state.progress = 0;
              updateLoadingState();
              
              try {
                if (maskEditBtn) maskEditBtn.classList.add("hidden");
                const loading = document.getElementById("loading");
                if (loading) loading.classList.remove("hidden");
                const resultDiv = document.getElementById("result");
                if (resultDiv) resultDiv.classList.add("hidden");
                
                // Start processing
                startProcessing(0, 100);
                
                // Compress and process the image
                const compressionResult = await compressForServer(state.imageFile);
                const compressedFile = compressionResult.file;
                
                // Show compression info
                const originalMB = (state.imageFile.size / (1024*1024)).toFixed(1);
                const compressedMB = (compressionResult.compressedSize / (1024*1024)).toFixed(1);
                const qualityMsg = `Optimized from ${originalMB}MB to ${compressedMB}MB (${compressionResult.dimensions})`;
                showToast(qualityMsg);
                
                // Convert to base64
                const base64Image = await fileToBase64(compressedFile);
                
                // API call - use mask data and prompt
                const response = await fetch("/api/edit", {
                  method: "POST",
                  headers: { 
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                  },
                  body: JSON.stringify({
                    image: base64Image,
                    imageName: state.imageFile.name,
                    imageType: state.imageFile.type,
                    prompt: prompt,
                    mask: maskData
                  })
                });
                
                // Stop processing
                stopProcessing();
                
                // Error handling
                if (!response.ok) {
                  let errorMessage = `Server error: ${response.status}`;
                  try {
                    const errorData = await response.json();
                    if (errorData.error) {
                      errorMessage += ` - ${errorData.error}`;
                    }
                  } catch (e) {
                    // Ignore
                  }
                  throw new Error(errorMessage);
                }
                
                // Parse response
                const contentType = response.headers.get("content-type");
                let data;
                if (contentType && contentType.includes("application/json")) {
                  data = await response.json();
                } else {
                  throw new Error("Expected JSON response but received different content type");
                }
                
                if (data.edited_image_url) {
                  // Store edited image URL in tab state
                  state.editedImageUrl = data.edited_image_url;
                  state.loading = false;
                  updateLoadingState();
                  
                  showResult(data.edited_image_url);
                } else {
                  throw new Error("Invalid response format: missing edited_image_url");
                }
              } catch (err) {
                console.error("Detailed error:", err);
                // Stop processing on error
                stopProcessing();
                state.loading = false;
                updateLoadingState();
                
                const loading = document.getElementById("loading");
                if (loading) loading.classList.add("hidden");
                if (maskEditBtn) maskEditBtn.classList.remove("hidden");
                alert("Error: " + err.message);
              }
            });
          }
        }
        
        // Handle Style Transfer tab
        else if (currentTab === 'styleTransfer') {
          const styleImageInput = document.getElementById("styleImageInput");
          const styleDropzone = document.getElementById("styleDropzone");
          const styleImagePreview = document.getElementById("styleImagePreview");
          const stylePreviewImg = document.getElementById("stylePreviewImg");
          const stylePreviewName = document.getElementById("stylePreviewName");
          const stylePreviewSize = document.getElementById("stylePreviewSize");
          const styleEditBtn = document.getElementById("styleEditBtn");
          const styleTransferGrid = document.getElementById("styleTransferGrid");
          const intensitySlider = document.getElementById('styleIntensity');
          const intensityValue = document.getElementById('intensityValue');
          
          // Restore image preview if exists
          if (state.imageUrl && styleImagePreview && stylePreviewImg) {
            stylePreviewImg.src = state.imageUrl;
            if (stylePreviewName) stylePreviewName.textContent = state.imageFile ? state.imageFile.name : 'Uploaded image';
            if (stylePreviewSize) stylePreviewSize.textContent = state.imageFile ? (state.imageFile.size / (1024*1024)).toFixed(1) + " MB" : '';
            styleImagePreview.classList.remove("hidden");
          } else {
            if (styleImagePreview) styleImagePreview.classList.add("hidden");
          }
          
          // Initialize style buttons
          if (styleTransferGrid) {
            styleTransferGrid.querySelectorAll('.style-btn').forEach((button, index) => {
              const styles = Object.keys(stylePlaceholders);
              const style = styles[index % styles.length];
              
              // Check if this style is active
              const isActive = state.styles.includes(style);
              if (isActive) {
                button.classList.add('style-active');
                button.style.backgroundColor = '#2563eb';
                button.style.borderColor = '#2563eb';
                button.style.color = 'white';
              }
              
              button.addEventListener('click', () => {
                toggleStyle(button, style);
              });
            });
          }
          
          // Style intensity slider
          if (intensitySlider && intensityValue) {
            intensitySlider.value = state.intensity;
            const value = Math.round(state.intensity * 100);
            intensityValue.textContent = `${value}%`;
            
            intensitySlider.addEventListener('input', () => {
              const value = Math.round(intensitySlider.value * 100);
              intensityValue.textContent = `${value}%`;
              state.intensity = parseFloat(intensitySlider.value);
              saveTabState();
            });
          }
          
          // Restore result if exists
          if (state.editedImageUrl) {
            showResult(state.editedImageUrl);
          }
          
          // Set up events
          if (styleDropzone && styleImageInput) {
            styleDropzone.addEventListener("click", () => {
              // Clear previous file input to allow re-uploading the same file
              styleImageInput.value = '';
              styleImageInput.click();
            });
            styleDropzone.addEventListener("dragover", (e) => {
              e.preventDefault();
              styleDropzone.classList.add("border-blue-500", "bg-blue-50");
            });
            styleDropzone.addEventListener("dragleave", () => {
              styleDropzone.classList.remove("border-blue-500", "bg-blue-50");
            });
            styleDropzone.addEventListener("drop", (e) => {
              e.preventDefault();
              styleDropzone.classList.remove("border-blue-500", "bg-blue-50");
              if (e.dataTransfer.files.length) {
                const file = e.dataTransfer.files[0];
                handleImageUpload(file, 'style');
              }
            });
            
            styleImageInput.addEventListener("change", (e) => {
              // Prevent double event triggering
              e.stopPropagation();
              e.preventDefault();
              
              const file = styleImageInput.files[0];
              if (file) {
                handleImageUpload(file, 'style');
              }
            });
          }
          
          // Style Edit button
          if (styleEditBtn) {
            styleEditBtn.addEventListener("click", async () => {
              if (!state.imageFile || state.styles.length === 0) {
                alert("Please upload an image and select at least one style.");
                return;
              }
              
              state.loading = true;
              state.progress = 0;
              updateLoadingState();
              
              try {
                if (styleEditBtn) styleEditBtn.classList.add("hidden");
                const loading = document.getElementById("loading");
                if (loading) loading.classList.remove("hidden");
                const resultDiv = document.getElementById("result");
                if (resultDiv) resultDiv.classList.add("hidden");
                
                // Start processing
                startProcessing(0, 100);
                
                // Compress and process the image
                const compressionResult = await compressForServer(state.imageFile);
                const compressedFile = compressionResult.file;
                
                // Show compression info
                const originalMB = (state.imageFile.size / (1024*1024)).toFixed(1);
                const compressedMB = (compressionResult.compressedSize / (1024*1024)).toFixed(1);
                const qualityMsg = `Optimized from ${originalMB}MB to ${compressedMB}MB (${compressionResult.dimensions})`;
                showToast(qualityMsg);
                
                // Convert to base64
                const base64Image = await fileToBase64(compressedFile);
                
                // Construct prompt with style information
                const stylePrompt = state.styles.map(s => {
                  const styles = {
                    anime: "in anime style",
                    'studio ghibli': "in Studio Ghibli style",
                    picasso: "in Picasso's cubist style, abstract forms",
                    cyberpunk: "with cyberpunk neon lighting",
                    'van gogh': "in the style of Van Gogh, expressive brushstrokes",
                    lego: "as a LEGO diorama, plastic texture",
                    'pixel art': "in 16-bit pixel art style",
                    sketch: "as a pencil sketch, hand-drawn lines",
                    pixar: "in Pixar 3D animation style, soft lighting",
                    'desert mirage': "with desert mirage effect, heat haze"
                  };
                  return styles[s] || s;
                }).join(", ");
                
                // API call
                const response = await fetch("/api/edit", {
                  method: "POST",
                  headers: { 
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                  },
                  body: JSON.stringify({
                    image: base64Image,
                    imageName: state.imageFile.name,
                    imageType: state.imageFile.type,
                    prompt: stylePrompt,
                    style_intensity: state.intensity
                  })
                });
                
                // Stop processing
                stopProcessing();
                
                // Error handling
                if (!response.ok) {
                  let errorMessage = `Server error: ${response.status}`;
                  try {
                    const errorData = await response.json();
                    if (errorData.error) {
                      errorMessage += ` - ${errorData.error}`;
                    }
                  } catch (e) {
                    // Ignore
                  }
                  throw new Error(errorMessage);
                }
                
                // Parse response
                const contentType = response.headers.get("content-type");
                let data;
                if (contentType && contentType.includes("application/json")) {
                  data = await response.json();
                } else {
                  throw new Error("Expected JSON response but received different content type");
                }
                
                if (data.edited_image_url) {
                  // Store edited image URL in tab state
                  state.editedImageUrl = data.edited_image_url;
                  state.loading = false;
                  updateLoadingState();
                  
                  showResult(data.edited_image_url);
                } else {
                  throw new Error("Invalid response format: missing edited_image_url");
                }
              } catch (err) {
                console.error("Detailed error:", err);
                // Stop processing on error
                stopProcessing();
                state.loading = false;
                updateLoadingState();
                
                const loading = document.getElementById("loading");
                if (loading) loading.classList.add("hidden");
                if (styleEditBtn) styleEditBtn.classList.remove("hidden");
                alert("Error: " + err.message);
              }
            });
          }
        }
      }
      
      // Reset UI elements to ensure no cross-contamination
      function resetUI() {
        // Hide all previews
        document.querySelectorAll('.hidden').forEach(el => {
          if (el.classList.contains('image-preview')) {
            el.classList.add('hidden');
          }
        });
        
        // Reset mask editor
        const maskEditor = document.getElementById('maskEditor');
        if (maskEditor) {
          maskEditor.classList.add('hidden');
        }
        
        // Reset result
        const resultDiv = document.getElementById('result');
        if (resultDiv) {
          resultDiv.classList.add('hidden');
        }
      }
      
      // Save current tab state
      function saveTabState() {
        const state = tabStates[currentTab];
        
        if (currentTab === 'promptEdit') {
          const promptInput = document.getElementById("prompt");
          if (promptInput) {
            state.prompt = promptInput.value;
          }
        } 
        else if (currentTab === 'maskEdit') {
          const maskPromptInput = document.getElementById("maskPrompt");
          if (maskPromptInput) {
            state.prompt = maskPromptInput.value;
          }
          
          // Save mask data
          state.maskData = getMaskData();
        }
        else if (currentTab === 'styleTransfer') {
          // Save style selections
          const styleTransferGrid = document.getElementById("styleTransferGrid");
          if (styleTransferGrid) {
            state.styles = [];
            styleTransferGrid.querySelectorAll('.style-btn.style-active').forEach(button => {
              const styleName = button.textContent.trim().split(' ')[1].toLowerCase();
              state.styles.push(styleName);
            });
          }
          
          // Save intensity
          const intensitySlider = document.getElementById('styleIntensity');
          if (intensitySlider) {
            state.intensity = parseFloat(intensitySlider.value);
          }
        }
      }
      
      // Update loading state
      function updateLoadingState() {
        const state = tabStates[currentTab];
        const progressBar = document.getElementById('progressBar');
        const progressPercent = document.getElementById('progressPercent');
        
        if (progressBar && progressPercent) {
          progressBar.style.width = `${state.progress}%`;
          progressPercent.textContent = Math.round(state.progress);
        }
      }
      
      // Start processing
      function startProcessing(start, end) {
        const state = tabStates[currentTab];
        let current = start;
        const interval = setInterval(() => {
          if (current >= end) {
            clearInterval(interval);
          } else {
            current += 1;
            state.progress = current;
            updateLoadingState();
          }
        }, 50);
      }
      
      // Stop processing
      function stopProcessing() {
        const state = tabStates[currentTab];
        state.progress = 100;
        updateLoadingState();
        
        // Hide loading after a short delay
        setTimeout(() => {
          const loading = document.getElementById("loading");
          if (loading) loading.classList.add("hidden");
        }, 500);
      }
      
      // Tab functionality
      tabs.forEach(tab => {
        tab.addEventListener('click', () => {
          // Save current tab state before switching
          saveTabState();
          
          // Remove active class from all tabs and content
          tabs.forEach(t => t.classList.remove('active'));
          tabContents.forEach(c => c.classList.remove('active'));
          
          // Add active class to clicked tab and corresponding content
          tab.classList.add('active');
          currentTab = tab.getAttribute('data-tab');
          const contentElement = document.getElementById(`${currentTab}Tab`);
          
          if (contentElement) {
            contentElement.classList.add('active');
            initTabState();
          }
        });
      });
      
      // Initialize the current tab
      initTabState();
      
      // Mask editor functionality
      function initMaskEditor() {
        const canvas = document.getElementById('maskCanvas');
        const img = document.getElementById('maskBaseImage');
        const overlay = document.getElementById('maskOverlay');
        
        if (!img || !img.src || !canvas) return;
        
        // Set canvas dimensions to match image
        const rect = img.getBoundingClientRect();
        const canvasWidth = Math.min(rect.width, 1000);
        const canvasHeight = Math.min(rect.height, 1000);
        
        // Fix for canvas performance warning
        canvas.setAttribute('willReadFrequently', 'true');
        
        canvas.width = canvasWidth;
        canvas.height = canvasHeight;
        canvas.style.width = '100%';
        canvas.style.height = '100%';
        
        maskCanvas = canvas;
        maskCtx = canvas.getContext('2d', { willReadFrequently: true });
        
        // Clear canvas
        maskCtx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Set up drawing tools
        setupDrawingTools();
        
        // Initialize overlay
        if (overlay) {
          overlay.style.width = '100%';
          overlay.style.height = '100%';
          overlay.style.position = 'absolute';
          overlay.style.top = '0';
          overlay.style.left = '0';
          overlay.style.pointerEvents = 'none';
          overlay.style.zIndex = '2';
        }
      }
      
      function setupDrawingTools() {
        if (!maskCanvas || !maskCtx) return;
        
        let isDrawing = false;
        
        // Tool selection
        document.querySelectorAll('.mask-tool').forEach(tool => {
          tool.addEventListener('click', () => {
            document.querySelectorAll('.mask-tool').forEach(t => t.classList.remove('active'));
            tool.classList.add('active');
          });
        });
        
        // Brush size
        const brushSizeInput = document.getElementById('brushSize');
        const brushPreview = document.querySelector('.brush-size-preview');
        
        if (brushSizeInput && brushPreview) {
          brushSizeInput.addEventListener('input', () => {
            const size = parseInt(brushSizeInput.value);
            brushPreview.style.width = `${size/2}px`;
            brushPreview.style.height = `${size/2}px`;
          });
        }
        
        // Drawing events
        maskCanvas.addEventListener('mousedown', startDrawing);
        maskCanvas.addEventListener('mousemove', draw);
        maskCanvas.addEventListener('mouseup', stopDrawing);
        maskCanvas.addEventListener('mouseleave', stopDrawing);
        
        maskCanvas.addEventListener('touchstart', (e) => {
          e.preventDefault();
          startDrawing({ clientX: e.touches[0].clientX, clientY: e.touches[0].clientY });
        });
        maskCanvas.addEventListener('touchmove', (e) => {
          e.preventDefault();
          draw({ clientX: e.touches[0].clientX, clientY: e.touches[0].clientY });
        });
        maskCanvas.addEventListener('touchend', stopDrawing);
        
        // Undo/Redo
        const undoTool = document.querySelector('[data-tool="undo"]');
        const redoTool = document.querySelector('[data-tool="redo"]');
        
        if (undoTool) {
          undoTool.addEventListener('click', undo);
        }
        
        if (redoTool) {
          redoTool.addEventListener('click', redo);
        }
        
        function startDrawing(e) {
          isDrawing = true;
          saveState();
          draw(e);
        }
        
        function draw(e) {
          if (!isDrawing) return;
          
          const rect = maskCanvas.getBoundingClientRect();
          const x = e.clientX - rect.left;
          const y = e.clientY - rect.top;
          
          maskCtx.beginPath();
          
          // Check current tool
          const currentTool = document.querySelector('.mask-tool.active').getAttribute('data-tool');
          
          if (currentTool === 'brush') {
            // Blue for keep areas
            maskCtx.globalCompositeOperation = 'source-over';
            maskCtx.strokeStyle = 'rgba(0, 0, 255, 0.5)';
          } else if (currentTool === 'eraser') {
            // Red for remove areas (with transparency)
            maskCtx.globalCompositeOperation = 'source-over';
            maskCtx.strokeStyle = 'rgba(255, 0, 0, 0.5)';
          }
          
          const brushSize = parseInt(document.getElementById('brushSize').value);
          maskCtx.lineWidth = brushSize;
          maskCtx.lineCap = 'round';
          maskCtx.lineTo(x, y);
          maskCtx.stroke();
          maskCtx.beginPath();
          maskCtx.moveTo(x, y);
        }
        
        function stopDrawing() {
          isDrawing = false;
          maskCtx.beginPath();
        }
        
        // Mask history for undo/redo
        const maskHistory = [];
        let historyIndex = -1;
        
        function saveState() {
          maskHistory.length = historyIndex + 1;
          maskHistory.push(maskCtx.getImageData(0, 0, maskCanvas.width, maskCanvas.height));
          historyIndex = maskHistory.length - 1;
        }
        
        function undo() {
          if (historyIndex <= 0) return;
          
          historyIndex--;
          maskCtx.putImageData(maskHistory[historyIndex], 0, 0);
        }
        
        function redo() {
          if (historyIndex >= maskHistory.length - 1) return;
          
          historyIndex++;
          maskCtx.putImageData(maskHistory[historyIndex], 0, 0);
        }
      }
      
      // Function to get mask data as base64
      function getMaskData() {
        if (!maskCanvas) return null;
        
        return maskCanvas.toDataURL('image/png');
      }
      
      // === Toast Notification System ===
      function showToast(message) {
        if (!toast) return;
        toast.textContent = message;
        toast.classList.add('show');
        
        setTimeout(() => {
          toast.classList.remove('show');
        }, 3000);
      }

      // Detect Facebook WebView
      function isFacebookWebView() {
        const ua = navigator.userAgent || navigator.vendor || window.opera;
        return (ua.indexOf("FBAN") > -1) || (ua.indexOf("FBAV") > -1) || 
               (ua.indexOf("FB_IAB") > -1) || (ua.indexOf("FB4A") > -1);
      }

      // === Rest of the JS ===
      function handleImageUpload(file, type) {
        // Check if file is an image
        if (!file.type.match('image.*')) {
          alert('Please select an image file (PNG, JPG, GIF)');
          return;
        }
        
        const reader = new FileReader();
        reader.onload = () => {
          const state = tabStates[currentTab];
          
          // Store file and URL in tab state
          state.imageFile = file;
          state.imageUrl = reader.result;
          
          // Update UI based on tab
          if (type === 'prompt') {
            const imagePreview = document.getElementById("imagePreview");
            const previewImg = document.getElementById("previewImg");
            const previewName = document.getElementById("previewName");
            const previewSize = document.getElementById("previewSize");
            
            if (previewImg) previewImg.src = reader.result;
            if (previewName) previewName.textContent = file.name;
            if (previewSize) previewSize.textContent = (file.size / (1024*1024)).toFixed(1) + " MB";
            if (imagePreview) imagePreview.classList.remove("hidden");
          } 
          else if (type === 'mask') {
            const maskImagePreview = document.getElementById("maskImagePreview");
            const maskPreviewImg = document.getElementById("maskPreviewImg");
            const maskPreviewName = document.getElementById("maskPreviewName");
            const maskPreviewSize = document.getElementById("maskPreviewSize");
            
            if (maskPreviewImg) maskPreviewImg.src = reader.result;
            if (maskPreviewName) maskPreviewName.textContent = file.name;
            if (maskPreviewSize) maskPreviewSize.textContent = (file.size / (1024*1024)).toFixed(1) + " MB";
            if (maskImagePreview) maskImagePreview.classList.remove("hidden");
            
            // Show mask editor
            const maskEditor = document.getElementById('maskEditor');
            const maskBaseImage = document.getElementById('maskBaseImage');
            if (maskEditor) maskEditor.classList.remove('hidden');
            if (maskBaseImage) maskBaseImage.src = reader.result;
            
            // Initialize mask editor immediately
            setTimeout(() => {
              initMaskEditor();
            }, 100);
          }
          else if (type === 'style') {
            const styleImagePreview = document.getElementById("styleImagePreview");
            const stylePreviewImg = document.getElementById("stylePreviewImg");
            const stylePreviewName = document.getElementById("stylePreviewName");
            const stylePreviewSize = document.getElementById("stylePreviewSize");
            
            if (stylePreviewImg) stylePreviewImg.src = reader.result;
            if (stylePreviewName) stylePreviewName.textContent = file.name;
            if (stylePreviewSize) stylePreviewSize.textContent = (file.size / (1024*1024)).toFixed(1) + " MB";
            if (styleImagePreview) styleImagePreview.classList.remove("hidden");
          }
          
          showToast("Image uploaded successfully");
        };
        reader.readAsDataURL(file);
      }

      // === Vertical Reveal Slider (Mobile-Fixed) ===
      const sliderHandle = document.getElementById('sliderHandle');
      const imageOverlay = document.getElementById('imageOverlay');
      const beforeImage = document.getElementById('beforeImage');
      const afterImage = document.getElementById('afterImage');
      
      if (sliderHandle && imageOverlay && beforeImage && afterImage) {
        let isDragging = false;

        function handleMove(e) {
          if (!isDragging) return;
          
          e.preventDefault(); // Prevent scrolling while dragging
          
          const container = sliderHandle.parentElement;
          const rect = container.getBoundingClientRect();
          const clientX = e.clientX || (e.touches && e.touches[0].clientX);
          if (!clientX) return;
          
          let x = clientX - rect.left;
          const maxLeft = rect.width - 40;
          const clampedX = Math.max(0, Math.min(maxLeft, x));
          const percent = (clampedX / rect.width) * 100;
          
          sliderHandle.style.left = clampedX + 'px';
          imageOverlay.style.clipPath = `inset(0 ${100 - (clampedX / rect.width) * 100}% 0 0)`;
        }

        function stopDragging() {
          isDragging = false;
          document.removeEventListener('mousemove', handleMove);
          document.removeEventListener('mouseup', stopDragging);
          document.removeEventListener('touchmove', handleMove);
          document.removeEventListener('touchend', stopDragging);
        }

        sliderHandle.addEventListener('mousedown', (e) => {
          isDragging = true;
          document.addEventListener('mousemove', handleMove);
          document.addEventListener('mouseup', stopDragging);
          e.preventDefault();
        });

        sliderHandle.addEventListener('touchstart', (e) => {
          isDragging = true;
          document.addEventListener('touchmove', handleMove, { passive: false });
          document.addEventListener('touchend', stopDragging);
          e.preventDefault();
        });
      }
      
      // === Style Presets ===
      function toggleStyle(button, style) {
        const state = tabStates[currentTab];
        const isActive = button.classList.contains('style-active');
        
        if (isActive) {
          button.classList.remove('style-active');
          button.style.backgroundColor = '';
          button.style.borderColor = 'var(--border-primary)';
          button.style.color = 'var(--text-primary)';
          
          // Remove from state
          const index = state.styles.indexOf(style);
          if (index > -1) {
            state.styles.splice(index, 1);
          }
        } else {
          button.classList.add('style-active');
          button.style.backgroundColor = '#2563eb';
          button.style.borderColor = '#2563eb';
          button.style.color = 'white';
          
          // Add to state
          state.styles.push(style);
        }
        
        saveTabState();
      }

      // Show result image
      function showResult(editedImageUrl) {
        const beforeImage = document.getElementById('beforeImage');
        const afterImage = document.getElementById('afterImage');
        const imageOverlay = document.getElementById('imageOverlay');
        const resultDiv = document.getElementById('result');
        const sliderHandle = document.getElementById('sliderHandle');
        
        if (beforeImage && afterImage && resultDiv) {
          const state = tabStates[currentTab];
          
          // Set image sources
          beforeImage.src = state.imageUrl;
          afterImage.src = editedImageUrl;
          
          // Show result
          resultDiv.classList.remove("hidden");
          
          // Reset slider to 50%
          if (sliderHandle && imageOverlay) {
            const container = sliderHandle.parentElement;
            const midPoint = (container.offsetWidth - 40) / 2;
            sliderHandle.style.left = midPoint + 'px';
            imageOverlay.style.clipPath = 'inset(0 50% 0 0)';
          }
          
          // Set up download functionality
          setupDownload(editedImageUrl);
          
          // Smooth scroll to result
          setTimeout(() => {
            resultDiv.scrollIntoView({ 
              behavior: 'smooth', 
              block: 'start' 
            });
          }, 300);
        }
      }

      // Setup download functionality with Facebook WebView compatibility
      function setupDownload(imageUrl) {
        const downloadBtn = document.getElementById("downloadBtn");
        const downloadInstructions = document.getElementById("downloadInstructions");
        
        // Clear previous instructions
        if (downloadInstructions) {
          downloadInstructions.textContent = '';
        }
        
        // For Facebook WebView, use a different approach
        if (isFacebookWebView()) {
          downloadBtn.onclick = async () => {
            try {
              // Fetch the image as blob
              const response = await fetch(imageUrl);
              const blob = await response.blob();
              
              // Create object URL
              const url = URL.createObjectURL(blob);
              
              // For mobile devices, open in new tab
              const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
              if (isMobile) {
                // Open in new window/tab
                window.open(url, '_blank');
                
                // Show instructions
                if (downloadInstructions) {
                  downloadInstructions.textContent = 'Tap and hold the image to save it to your device';
                }
                showToast('Image opened in new tab - tap and hold to save');
              } else {
                // For desktop Facebook WebView (rare), try normal download
                const a = document.createElement("a");
                a.href = url;
                a.download = "kamuy-edited.png";
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                showToast("Download started");
              }
            } catch (err) {
              alert("Download failed: " + err.message);
            }
          };
        } else {
          // Standard download for regular browsers
          downloadBtn.onclick = () => {
            fetch(imageUrl)
              .then(res => res.blob())
              .then(blob => {
                const url = URL.createObjectURL(blob);
                const a = document.createElement("a");
                a.href = url;
                a.download = "kamuy-edited.png";
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                showToast("Download started");
              })
              .catch(err => alert("Download failed: " + err.message));
          };
        }
      }

      // === Processing Functions ===
      function fileToBase64(file) {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onload = () => {
            // Remove the data URL prefix (e.g., "image/png;base64,")
            const base64 = reader.result.split(',')[1];
            resolve(base64);
          };
          reader.onerror = reject;
          reader.readAsDataURL(file);
        });
      }

      // Smart compression function
      async function compressForServer(file) {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onload = function(e) {
            const img = new Image();
            img.src = e.target.result;
            
            img.onload = function() {
              let width = img.width;
              let height = img.height;
              
              // Calculate aspect ratio
              const aspectRatio = width / height;
              
              // Maximum dimensions for good quality
              const maxDimension = 1920;
              
              // Scale down if needed, but maintain aspect ratio
              if (width > maxDimension || height > maxDimension) {
                if (width > height) {
                  width = maxDimension;
                  height = Math.round(width / aspectRatio);
                } else {
                  height = maxDimension;
                  width = Math.round(height * aspectRatio);
                }
              }
              
              // Create canvas and draw image
              const canvas = document.createElement('canvas');
              canvas.width = width;
              canvas.height = height;
              const ctx = canvas.getContext('2d');
              ctx.drawImage(img, 0, 0, width, height);
              
              // Start with high quality
              let quality = 0.9;
              const mime = file.type || 'image/jpeg';
              
              function tryCompression() {
                // Convert to blob with current quality
                canvas.toBlob(blob => {
                  if (!blob) {
                    reject(new Error('Canvas toBlob failed'));
                    return;
                  }
                  
                  // Calculate expected base64 size (rough estimate)
                  const base64Size = blob.size * 1.33; // Base64 adds ~33% overhead
                  
                  // For Facebook WebView, be more conservative
                  const maxSize = isFacebookWebView() ? 3.0 * 1024 * 1024 : 3.5 * 1024 * 1024;
                  
                  // Check if size is acceptable
                  if (base64Size <= maxSize || quality <= 0.3) {
                    const compressedFile = new File([blob], file.name, {
                      type: file.type,
                      lastModified: file.lastModified
                    });
                    
                    resolve({
                      file: compressedFile,
                      originalSize: file.size,
                      compressedSize: blob.size,
                      quality: quality,
                      dimensions: `${width}x${height}`
                    });
                  } else {
                    // Reduce quality and try again
                    quality -= 0.1;
                    tryCompression();
                  }
                }, mime, quality);
              }
              
              tryCompression();
            };
            
            img.onerror = function() {
              reject(new Error('Image load error'));
            };
          };
          
          reader.onerror = function() {
            reject(new Error('File reader error'));
          };
          
          reader.readAsDataURL(file);
        });
      }

      // === Dark Mode Toggle ===
      const darkModeToggle = document.getElementById('darkModeToggle');
      const body = document.body;

      const prefersDark = localStorage.getItem('kamuy_dark_mode') === 'true';
      if (prefersDark) {
        body.classList.add('dark');
        darkModeToggle.textContent = 'Light Mode';
      }

      if (darkModeToggle) {
        darkModeToggle.addEventListener('click', () => {
          body.classList.toggle('dark');
          if (body.classList.contains('dark')) {
            darkModeToggle.textContent = 'Light Mode';
            localStorage.setItem('kamuy_dark_mode', 'true');
          } else {
            darkModeToggle.textContent = 'Dark Mode';
            localStorage.setItem('kamuy_dark_mode', 'false');
          }
        });
      }
    });
  </script>
</body>
</html>
