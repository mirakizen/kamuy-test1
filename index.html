<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Kamuy - AI Image Editor</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    @import url('https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css');

    :root {
      --bg-primary: #f9fafb;
      --bg-secondary: #ffffff;
      --text-primary: #111827;
      --text-secondary: #4b5563;
      --border-primary: #e5e7eb;
      --btn-bg: #3b82f6;
      --btn-text: #ffffff;
      --tab-active: #2563eb;
      --tab-inactive: #e5e7eb;
    }

    .dark {
      --bg-primary: #111827;
      --bg-secondary: #1f2937;
      --text-primary: #f9fafb;
      --text-secondary: #d1d5db;
      --border-primary: #374151;
      --btn-bg: #2563eb;
      --btn-text: #ffffff;
      --tab-active: #3b82f6;
      --tab-inactive: #4b5563;
    }

    body {
      font-family: 'Inter', sans-serif;
      background-color: var(--bg-primary);
      color: var(--text-primary);
      transition: background-color 0.3s ease, color 0.3s ease;
      touch-action: manipulation;
    }

    .container {
      background-color: var(--bg-secondary);
      border-radius: 0.75rem;
      box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
      overflow: hidden;
    }

    /* Tab styles */
    .tabs-container {
      display: flex;
      border-bottom: 1px solid var(--border-primary);
    }
    
    .tab {
      flex: 1;
      text-align: center;
      padding: 0.75rem 0;
      cursor: pointer;
      transition: all 0.3s ease;
      position: relative;
      font-weight: 500;
      color: var(--text-secondary);
    }
    
    .tab.active {
      color: var(--tab-active);
    }
    
    .tab.active::after {
      content: '';
      position: absolute;
      bottom: -1px;
      left: 0;
      width: 100%;
      height: 3px;
      background-color: var(--tab-active);
    }
    
    .tab:hover:not(.active) {
      background-color: rgba(37, 99, 235, 0.05);
    }
    
    .tab-content {
      display: none;
      animation: fadeIn 0.3s ease;
    }
    
    .tab-content.active {
      display: block;
    }
    
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(5px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .dropzone {
      border: 3px dashed var(--border-primary);
      border-radius: 12px;
      background: #f8f9fa;
      transition: all 0.2s ease;
      color: var(--text-secondary);
    }

    .dark .dropzone {
      background: #1f2937;
      color: #d1d5db;
    }

    .dropzone:hover {
      border-color: #0d6efd;
      background: #f1f3f5;
    }

    .dark .dropzone:hover {
      background: #374151;
    }

    .spinner {
      display: inline-block;
      width: 1em;
      height: 1em;
      border: 2px solid #f3f3f3;
      border-top: 2px solid #fff;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    .style-btn {
      @apply px-3 py-1 text-xs font-medium rounded-full border transition-all duration-200 cursor-pointer relative;
      border-color: var(--border-primary);
      color: var(--text-primary);
      background-color: transparent;
    }

    .style-btn:hover {
      background-color: #2563eb;
      color: white;
      transform: scale(1.05);
    }

    .style-btn.style-active {
      background-color: #2563eb;
      color: white;
    }

    .tooltip {
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%);
      background: #1f2937;
      color: white;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 0.75rem;
      white-space: nowrap;
      z-index: 10;
      opacity: 0;
      visibility: hidden;
      transition: all 0.2s ease;
      margin-bottom: 4px;
    }

    .style-btn:hover .tooltip {
      opacity: 1;
      visibility: visible;
    }

    .style-grid {
      display: grid;
      grid-template-columns: repeat(5, 1fr);
      gap: 0.5rem;
    }

    .toast {
      position: fixed;
      top: 20px;
      right: 20px;
      max-width: 300px;
      padding: 12px 16px;
      border-radius: 8px;
      background: #1f2937;
      color: white;
      font-size: 0.875rem;
      box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
      transform: translateX(120%);
      opacity: 0;
      transition: all 0.3s ease;
      z-index: 50;
    }

    .toast.show {
      transform: translateX(0);
      opacity: 1;
    }

    /* Enhanced Loading Screen */
    .loading-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 200px;
      padding: 1rem;
    }

    .ai-loader {
      position: relative;
      width: 80px;
      height: 80px;
      margin-bottom: 1.5rem;
    }

    .loader-ring {
      position: absolute;
      width: 100%;
      height: 100%;
      border: 3px solid transparent;
      border-top-color: #2563eb;
      border-radius: 50%;
      animation: rotate 1.5s linear infinite;
    }

    .loader-ring:nth-child(2) {
      border: 3px solid transparent;
      border-right-color: #8b5cf6;
      animation-delay: -0.375s;
    }

    .loader-ring:nth-child(3) {
      border: 3px solid transparent;
      border-bottom-color: #06b6d4;
      animation-delay: -0.75s;
    }

    .loader-dot {
      position: absolute;
      width: 16px;
      height: 16px;
      background-color: #2563eb;
      border-radius: 50%;
      top: 0;
      left: 50%;
      margin: -8px 0 0 -8px;
      animation: pulse 1.5s ease-in-out infinite;
    }

    .loader-stages {
      display: flex;
      gap: 0.5rem;
      margin-top: 1rem;
    }

    .stage {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background-color: #cbd5e1;
      transition: all 0.3s ease;
    }

    .stage.active {
      background-color: #2563eb;
      transform: scale(1.3);
    }

    .loading-text {
      font-size: 1.1rem;
      font-weight: 500;
      color: var(--text-primary);
      min-height: 1.5rem;
      text-align: center;
    }

    @keyframes rotate {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    @keyframes pulse {
      0%, 100% { transform: scale(1); opacity: 1; }
      50% { transform: scale(1.5); opacity: 0.5; }
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    @media (max-width: 640px) {
      .style-grid {
        grid-template-columns: repeat(3, 1fr);
      }
      .dropzone {
        padding: 1rem;
      }
      .spinner {
        width: 1.2em;
        height: 1.2em;
      }
    }

    /* Vertical Reveal Slider */
    .comparison-container {
      position: relative;
      width: 100%;
      height: auto;
      overflow: hidden;
      border-radius: 0.5rem;
      border: 1px solid var(--border-primary);
      touch-action: none;
    }

    .comparison-image {
      display: block;
      width: 100%;
      height: auto;
    }

    .image-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      pointer-events: none;
    }

    .image-overlay img {
      width: 100%;
      height: auto;
    }

    .slider-handle {
      position: absolute;
      top: 0;
      left: 50%;
      width: 40px;
      height: 100%;
      cursor: ew-resize;
      z-index: 3;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(255,255,255,0.8);
      border-left: 1px solid #d1d5db;
      border-right: 1px solid #d1d5db;
      touch-action: none;
    }

    .dark .slider-handle {
      background: rgba(0,0,0,0.8);
      border-left: 1px solid #374151;
      border-right: 1px solid #374151;
    }

    .slider-handle::before {
      content: "↔";
      font-size: 24px;
      color: #4b5563;
      opacity: 0.8;
    }

    .dark .slider-handle::before {
      color: #d1d5db;
    }

    .slider-instruction {
      text-align: center;
      font-size: 0.875rem;
      color: var(--text-secondary);
      margin-top: 0.25rem;
      font-style: italic;
    }

    /* History Panel */
    .history-panel {
      position: fixed;
      top: 0;
      right: -320px;
      width: 300px;
      height: 100%;
      background: var(--bg-secondary);
      border-left: 1px solid var(--border-primary);
      box-shadow: -4px 0 6px -2px rgba(0,0,0,0.1);
      z-index: 40;
      transition: right 0.3s ease;
      overflow-y: auto;
      padding: 1rem;
    }

    .history-panel.open {
      right: 0;
    }

    .history-item {
      border: 1px solid var(--border-primary);
      border-radius: 8px;
      padding: 0.5rem;
      margin-bottom: 0.5rem;
      cursor: pointer;
    }

    .history-item img {
      width: 100%;
      border-radius: 4px;
      margin-bottom: 0.25rem;
    }

    .history-prompt {
      font-size: 0.75rem;
      color: var(--text-secondary);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .close-history {
      position: absolute;
      top: 10px;
      right: 10px;
      font-size: 1.5rem;
      color: var(--text-secondary);
      cursor: pointer;
    }

    .open-history {
      position: fixed;
      bottom: 20px;
      right: 20px;
      width: 50px;
      height: 50px;
      background: var(--btn-bg);
      color: var(--btn-text);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 4px 6px -1px rgba(0,0,0,0.1);
      z-index: 30;
      cursor: pointer;
    }

    .dark .open-history {
      background: #2563eb;
    }
    
    /* Facebook WebView Warning */
    .fb-warning {
      display: none;
      background-color: #fff1e6;
      border: 1px solid #fed7aa;
      border-radius: 0.5rem;
      padding: 1rem;
      margin-top: 1rem;
      color: #7c2d12;
    }
    
    /* Mask Editor */
    .mask-container {
      position: relative;
      width: 100%;
      margin-top: 1rem;
    }
    
    .mask-canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      cursor: crosshair;
    }
    
    .mask-controls {
      display: flex;
      gap: 0.5rem;
      margin-top: 0.5rem;
      flex-wrap: wrap;
    }
    
    .mask-tool {
      padding: 0.25rem 0.5rem;
      border-radius: 4px;
      background-color: #e5e7eb;
      cursor: pointer;
      font-size: 0.875rem;
      transition: all 0.2s ease;
    }
    
    .mask-tool.active {
      background-color: #2563eb;
      color: white;
    }
    
    .mask-brush-size {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    
    .brush-size-preview {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background-color: #2563eb;
      transition: all 0.2s ease;
    }
    
    .mask-help {
      font-size: 0.75rem;
      color: #6b7280;
      margin-top: 0.5rem;
      text-align: center;
    }
    
    /* Style Transfer Enhancements */
    .style-intensity {
      margin-top: 0.5rem;
    }
    
    .style-intensity label {
      display: block;
      margin-bottom: 0.25rem;
      font-size: 0.875rem;
    }
    
    .intensity-slider {
      width: 100%;
      height: 4px;
      -webkit-appearance: none;
      appearance: none;
      background: #e5e7eb;
      border-radius: 2px;
      outline: none;
    }
    
    .intensity-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: #2563eb;
      cursor: pointer;
    }
    
    .intensity-value {
      text-align: center;
      margin-top: 0.25rem;
      font-size: 0.875rem;
      color: #6b7280;
    }
    
    /* Mask overlay for visual feedback */
    .mask-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 2;
    }
  </style>
</head>
<body class="bg-gray-50 min-h-screen flex items-center justify-center p-4 sm:p-6">
  <div class="w-full max-w-2xl mx-auto container" id="appContainer">
    <div class="p-6 sm:p-8">
      <div class="flex justify-between items-center mb-6">
        <h1 class="text-3xl font-bold text-center">✨ Kamuy</h1>
        <button id="darkModeToggle" class="px-3 py-1 bg-gray-200 dark:bg-gray-700 rounded-lg text-sm">
          Dark Mode
        </button>
      </div>
      
      <!-- Tab Navigation -->
      <div class="tabs-container mb-6">
        <div class="tab active" data-tab="promptEdit">Prompt Edit</div>
        <div class="tab" data-tab="maskEdit">Remove/Add Mask</div>
        <div class="tab" data-tab="styleTransfer">Style Transfer</div>
      </div>
      
      <!-- Tab Content -->
      <div id="promptEditTab" class="tab-content active">
        <p class="text-center mb-6 text-sm text-gray-500">Describe what you want changed - our AI understands natural language</p>
        
        <!-- Upload -->
        <div class="mb-6">
          <label class="block text-sm font-medium mb-2">Upload Image</label>
          <input type="file" id="imageInput" accept="image/*" class="hidden" />
          <div id="dropzone" class="dropzone w-full p-6 text-center cursor-pointer">
            <svg class="mx-auto h-12 w-12 text-gray-400" stroke="currentColor" fill="none" viewBox="0 0 48 48">
              <path d="M28 8H12a4 4 0 00-4 4v20m32-20a4 4 0 014 4v20M16 16l16 16m-16 0l16-16" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
            <p class="mt-2">Click to upload or drag and drop</p>
            <p class="text-xs">PNG, JPG, GIF up to 8MB (smart compression applied)</p>
          </div>
          <!-- Preview -->
          <div id="imagePreview" class="hidden mt-4 p-2 border rounded-lg bg-gray-50 flex items-center">
            <img id="previewImg" class="h-20 w-20 object-cover rounded" />
            <div class="ml-3">
              <p id="previewName" class="text-sm font-medium"></p>
              <p id="previewSize" class="text-sm"></p>
            </div>
          </div>
        </div>

        <!-- Prompt -->
        <div class="mb-6">
          <label for="prompt" class="block text-sm font-medium mb-2">Edit Prompt</label>
          <input type="text" id="prompt" placeholder="Change the car color to red" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500"/>
        </div>

        <!-- Style Presets (for Prompt Edit tab) -->
        <div class="mb-6">
          <label class="block text-sm font-medium mb-2">Style Presets</label>
          <div class="style-grid" id="promptStyleGrid">
            <button type="button" class="style-btn">
              🎨 Anime
              <span class="tooltip">Transform into vibrant anime style</span>
            </button>
            <button type="button" class="style-btn">
              🎬 Ghibli
              <span class="tooltip">Studio Ghibli watercolor aesthetic</span>
            </button>
            <button type="button" class="style-btn">
              🎨 Picasso
              <span class="tooltip">Cubist abstraction and bold forms</span>
            </button>
            <button type="button" class="style-btn">
              🕹️ Cyberpunk
              <span class="tooltip">Neon lights, rain, futuristic</span>
            </button>
            <button type="button" class="style-btn">
              🖼️ Van Gogh
              <span class="tooltip">Expressive brushstrokes, textured</span>
            </button>
            <button type="button" class="style-btn">
              🧱 LEGO
              <span class="tooltip">Plastic brick diorama style</span>
            </button>
            <button type="button" class="style-btn">
              🎮 Pixel
              <span class="tooltip">16-bit retro video game style</span>
            </button>
            <button type="button" class="style-btn">
              🖋️ Sketch
              <span class="tooltip">Pencil drawing with shading</span>
            </button>
            <button type="button" class="style-btn">
              🧸 Pixar
              <span class="tooltip">3D animation, soft lighting</span>
            </button>
            <button type="button" class="style-btn">
              🏜️ Mirage
              <span class="tooltip">Heat haze, desert illusion</span>
            </button>
          </div>
        </div>

        <!-- Edit Button -->
        <button id="editBtn" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-semibold py-3 px-4 rounded-lg transition duration-200 flex items-center justify-center">
          <i class="fas fa-magic mr-2"></i> Edit Image
        </button>
      </div>
      
      <div id="maskEditTab" class="tab-content">
        <p class="text-center mb-6 text-sm text-gray-500">Paint what to keep or remove - precise object editing</p>
        
        <!-- Upload -->
        <div class="mb-6">
          <label class="block text-sm font-medium mb-2">Upload Image</label>
          <input type="file" id="maskImageInput" accept="image/*" class="hidden" />
          <div id="maskDropzone" class="dropzone w-full p-6 text-center cursor-pointer">
            <svg class="mx-auto h-12 w-12 text-gray-400" stroke="currentColor" fill="none" viewBox="0 0 48 48">
              <path d="M28 8H12a4 4 0 00-4 4v20m32-20a4 4 0 014 4v20M16 16l16 16m-16 0l16-16" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
            <p class="mt-2">Click to upload or drag and drop</p>
            <p class="text-xs">PNG, JPG, GIF up to 8MB (smart compression applied)</p>
          </div>
          <!-- Preview -->
          <div id="maskImagePreview" class="hidden mt-4 p-2 border rounded-lg bg-gray-50 flex items-center">
            <img id="maskPreviewImg" class="h-20 w-20 object-cover rounded" />
            <div class="ml-3">
              <p id="maskPreviewName" class="text-sm font-medium"></p>
              <p id="maskPreviewSize" class="text-sm"></p>
            </div>
          </div>
        </div>
        
        <!-- Mask Editor -->
        <div id="maskEditor" class="hidden mb-6">
          <div class="mask-container" style="position: relative; padding-top: 100%;">
            <img id="maskBaseImage" class="comparison-image" src="" alt="Base image for masking" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: contain;" />
            <canvas id="maskCanvas" class="mask-canvas" width="400" height="400"></canvas>
            <div id="maskOverlay" class="mask-overlay"></div>
          </div>
          
          <div class="mask-controls">
            <div class="mask-tool active" data-tool="brush">🖌️ Brush (Keep)</div>
            <div class="mask-tool" data-tool="eraser">🧹 Eraser (Remove)</div>
            <div class="mask-tool" data-tool="fill">🎨 Fill</div>
            <div class="mask-tool" data-tool="undo">↩️ Undo</div>
            <div class="mask-tool" data-tool="redo">↪️ Redo</div>
            
            <div class="mask-brush-size">
              <label for="brushSize">Size:</label>
              <input type="range" id="brushSize" min="1" max="50" value="10" class="w-24" />
              <div class="brush-size-preview" style="width: 10px; height: 10px;"></div>
            </div>
          </div>
          
          <div class="mask-help">
            <p>Draw on the image to select what to keep (blue) or remove (red)</p>
          </div>
        </div>
        
        <!-- Mask Prompt -->
        <div class="mb-6">
          <label for="maskPrompt" class="block text-sm font-medium mb-2">What would you like to change?</label>
          <input type="text" id="maskPrompt" placeholder="Remove the background" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500"/>
        </div>
        
        <!-- Edit Button -->
        <button id="maskEditBtn" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-semibold py-3 px-4 rounded-lg transition duration-200 flex items-center justify-center">
          <i class="fas fa-paint-brush mr-2"></i> Apply Mask Edit
        </button>
      </div>
      
      <div id="styleTransferTab" class="tab-content">
        <p class="text-center mb-6 text-sm text-gray-500">Transform your image into any artistic style</p>
        
        <!-- Upload -->
        <div class="mb-6">
          <label class="block text-sm font-medium mb-2">Upload Image</label>
          <input type="file" id="styleImageInput" accept="image/*" class="hidden" />
          <div id="styleDropzone" class="dropzone w-full p-6 text-center cursor-pointer">
            <svg class="mx-auto h-12 w-12 text-gray-400" stroke="currentColor" fill="none" viewBox="0 0 48 48">
              <path d="M28 8H12a4 4 0 00-4 4v20m32-20a4 4 0 014 4v20M16 16l16 16m-16 0l16-16" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
            <p class="mt-2">Click to upload or drag and drop</p>
            <p class="text-xs">PNG, JPG, GIF up to 8MB (smart compression applied)</p>
          </div>
          <!-- Preview -->
          <div id="styleImagePreview" class="hidden mt-4 p-2 border rounded-lg bg-gray-50 flex items-center">
            <img id="stylePreviewImg" class="h-20 w-20 object-cover rounded" />
            <div class="ml-3">
              <p id="stylePreviewName" class="text-sm font-medium"></p>
              <p id="stylePreviewSize" class="text-sm"></p>
            </div>
          </div>
        </div>

        <!-- Style Presets -->
        <div class="mb-6">
          <label class="block text-sm font-medium mb-2">Style Presets</label>
          <div class="style-grid" id="styleTransferGrid">
            <button type="button" class="style-btn">
              🎨 Anime
              <span class="tooltip">Transform into vibrant anime style</span>
            </button>
            <button type="button" class="style-btn">
              🎬 Ghibli
              <span class="tooltip">Studio Ghibli watercolor aesthetic</span>
            </button>
            <button type="button" class="style-btn">
              🎨 Picasso
              <span class="tooltip">Cubist abstraction and bold forms</span>
            </button>
            <button type="button" class="style-btn">
              🕹️ Cyberpunk
              <span class="tooltip">Neon lights, rain, futuristic</span>
            </button>
            <button type="button" class="style-btn">
              🖼️ Van Gogh
              <span class="tooltip">Expressive brushstrokes, textured</span>
            </button>
            <button type="button" class="style-btn">
              🧱 LEGO
              <span class="tooltip">Plastic brick diorama style</span>
            </button>
            <button type="button" class="style-btn">
              🎮 Pixel
              <span class="tooltip">16-bit retro video game style</span>
            </button>
            <button type="button" class="style-btn">
              🖋️ Sketch
              <span class="tooltip">Pencil drawing with shading</span>
            </button>
            <button type="button" class="style-btn">
              🧸 Pixar
              <span class="tooltip">3D animation, soft lighting</span>
            </button>
            <button type="button" class="style-btn">
              🏜️ Mirage
              <span class="tooltip">Heat haze, desert illusion</span>
            </button>
          </div>
          
          <!-- Style Intensity Slider -->
          <div class="style-intensity mt-4">
            <label for="styleIntensity">Style Intensity</label>
            <input type="range" id="styleIntensity" class="intensity-slider" min="0.1" max="1.0" step="0.1" value="0.7">
            <div class="intensity-value">Intensity: <span id="intensityValue">70%</span></div>
          </div>
        </div>

        <!-- Edit Button -->
        <button id="styleEditBtn" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-semibold py-3 px-4 rounded-lg transition duration-200 flex items-center justify-center">
          <i class="fas fa-palette mr-2"></i> Apply Style
        </button>
      </div>

      <!-- Loading -->
      <div id="loading" class="hidden mt-4 text-center text-gray-600">
        <div class="loading-container">
          <div class="ai-loader">
            <div class="loader-ring"></div>
            <div class="loader-ring"></div>
            <div class="loader-ring"></div>
            <div class="loader-dot"></div>
          </div>
          <div class="loading-text" id="loadingText">Analyzing your image...</div>
          <div class="loader-stages">
            <div class="stage active" id="stage1"></div>
            <div class="stage" id="stage2"></div>
            <div class="stage" id="stage3"></div>
            <div class="stage" id="stage4"></div>
          </div>
        </div>
      </div>

      <!-- Result -->
      <div id="result" class="hidden mt-6">
        <h3 class="text-lg font-medium mb-2">✨ Edited Image</h3>
        <div class="comparison-container relative">
          <img id="beforeImage" class="comparison-image" src="" alt="Original" />
          <div class="image-overlay" id="imageOverlay">
            <img id="afterImage" class="comparison-image" src="" alt="Edited" />
          </div>
          <div class="slider-handle" id="sliderHandle"></div>
        </div>
        <p class="slider-instruction">Drag left/right to compare before/after</p>

        <!-- Download Button -->
        <button id="downloadBtn" class="mt-3 w-full bg-green-600 hover:bg-green-700 text-white font-semibold py-2 px-4 rounded-lg transition duration-200">
          <i class="fas fa-download mr-2"></i> Download Image
        </button>
        <p id="downloadInstructions" class="download-instructions"></p>
      </div>
    </div>
  </div>

  <!-- Toast Notification -->
  <div id="toast" class="toast">Image uploaded successfully</div>

  <!-- History Panel -->
  <div id="historyPanel" class="history-panel">
    <h3 class="text-lg font-semibold mb-4">Recent Edits</h3>
    <div id="historyList"></div>
    <div class="close-history" id="closeHistory">&times;</div>
  </div>

  <!-- Open History Button -->
  <div id="openHistory" class="open-history">
    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path>
    </svg>
  </div>

  <script>
    // Declare all critical variables at the top to avoid TDZ issues
    let promptSelectedStyles = new Set();
    let maskSelectedStyles = new Set();
    let styleTransferSelectedStyles = new Set();
    let currentTab = 'promptEdit';
    let maskCanvas = null;
    let maskCtx = null;
    let isDrawing = false;
    let currentTool = 'brush';
    let brushSize = 10;
    let maskHistory = [];
    let historyIndex = -1;
    
    // Style placeholders and default values
    const defaultPlaceholder = "Change the car color to red";
    const stylePlaceholders = {
      anime: "Make it anime-style with vibrant colors",
      'studio ghibli': "Transform into a Studio Ghibli scene",
      picasso: "in Picasso's cubist style, abstract forms",
      cyberpunk: "Cyberpunk neon lights and rain effects",
      'van gogh': "in the style of Van Gogh, expressive brushstrokes",
      lego: "as a LEGO diorama, plastic texture",
      'pixel art': "in 16-bit pixel art style",
      sketch: "as a pencil sketch, hand-drawn lines",
      pixar: "in Pixar 3D animation style, soft lighting",
      'desert mirage': "with desert mirage effect, heat haze"
    };
    
    // Loading stages
    const loadingStages = [
      { text: "Analyzing your image...", stage: 0 },
      { text: "Understanding visual elements...", stage: 1 },
      { text: "Applying AI magic...", stage: 2 },
      { text: "Finalizing your masterpiece...", stage: 3 }
    ];
    
    // Initialize the app when DOM is ready
    document.addEventListener('DOMContentLoaded', function() {
      // DOM elements
      const tabs = document.querySelectorAll('.tab');
      const tabContents = document.querySelectorAll('.tab-content');
      const toast = document.getElementById('toast');
      const dropzone = document.getElementById("dropzone");
      const imageInput = document.getElementById("imageInput");
      const maskDropzone = document.getElementById("maskDropzone");
      const maskImageInput = document.getElementById("maskImageInput");
      const styleDropzone = document.getElementById("styleDropzone");
      const styleImageInput = document.getElementById("styleImageInput");
      
      // Prompt elements
      const imagePreview = document.getElementById("imagePreview");
      const previewImg = document.getElementById("previewImg");
      const previewName = document.getElementById("previewName");
      const previewSize = document.getElementById("previewSize");
      const promptInput = document.getElementById("prompt");
      const editBtn = document.getElementById("editBtn");
      const promptStyleGrid = document.getElementById("promptStyleGrid");
      
      // Mask elements
      const maskImagePreview = document.getElementById("maskImagePreview");
      const maskPreviewImg = document.getElementById("maskPreviewImg");
      const maskPreviewName = document.getElementById("maskPreviewName");
      const maskPreviewSize = document.getElementById("maskPreviewSize");
      const maskPromptInput = document.getElementById("maskPrompt");
      const maskEditBtn = document.getElementById("maskEditBtn");
      
      // Style elements
      const styleImagePreview = document.getElementById("styleImagePreview");
      const stylePreviewImg = document.getElementById("stylePreviewImg");
      const stylePreviewName = document.getElementById("stylePreviewName");
      const stylePreviewSize = document.getElementById("stylePreviewSize");
      const styleEditBtn = document.getElementById("styleEditBtn");
      const styleTransferGrid = document.getElementById("styleTransferGrid");
      
      // Result elements
      const loading = document.getElementById("loading");
      const resultDiv = document.getElementById("result");
      const downloadBtn = document.getElementById("downloadBtn");
      const downloadInstructions = document.getElementById("downloadInstructions");
      const beforeImage = document.getElementById('beforeImage');
      const afterImage = document.getElementById('afterImage');
      const imageOverlay = document.getElementById('imageOverlay');
      const sliderHandle = document.getElementById('sliderHandle');
      
      // Loading screen elements
      const loadingText = document.getElementById('loadingText');
      const stages = [
        document.getElementById('stage1'),
        document.getElementById('stage2'),
        document.getElementById('stage3'),
        document.getElementById('stage4')
      ];
      
      // Style intensity elements
      const intensitySlider = document.getElementById('styleIntensity');
      const intensityValue = document.getElementById('intensityValue');
      
      // Initialize style buttons for all tabs
      function initStyleButtons() {
        // Prompt Edit tab buttons
        if (promptStyleGrid) {
          promptStyleGrid.querySelectorAll('.style-btn').forEach((button, index) => {
            const styles = Object.keys(stylePlaceholders);
            const style = styles[index % styles.length];
            
            button.addEventListener('click', () => {
              toggleStyle(button, style, 'promptEdit');
            });
          });
        }
        
        // Style Transfer tab buttons
        if (styleTransferGrid) {
          styleTransferGrid.querySelectorAll('.style-btn').forEach((button, index) => {
            const styles = Object.keys(stylePlaceholders);
            const style = styles[index % styles.length];
            
            button.addEventListener('click', () => {
              toggleStyle(button, style, 'styleTransfer');
            });
          });
        }
      }
      
      // Tab functionality
      tabs.forEach(tab => {
        tab.addEventListener('click', () => {
          // Remove active class from all tabs and content
          tabs.forEach(t => t.classList.remove('active'));
          tabContents.forEach(c => c.classList.remove('active'));
          
          // Add active class to clicked tab and corresponding content
          tab.classList.add('active');
          const tabName = tab.getAttribute('data-tab');
          currentTab = tabName;
          const contentElement = document.getElementById(`${tabName}Tab`);
          
          // Critical fix: Check if content element exists before accessing classList
          if (contentElement) {
            contentElement.classList.add('active');
            
            // Initialize tab-specific functionality
            if (tabName === 'maskEdit') {
              initMaskEditor();
            } else if (tabName === 'styleTransfer') {
              setupStyleTransferTab();
            }
            
            // Update placeholder based on current tab
            updatePlaceholder();
          }
        });
      });
      
      // Initialize the current tab
      updatePlaceholder();
      
      // Initialize style buttons
      initStyleButtons();
      
      // Style intensity slider
      if (intensitySlider && intensityValue) {
        intensitySlider.addEventListener('input', () => {
          const value = Math.round(intensitySlider.value * 100);
          intensityValue.textContent = `${value}%`;
        });
      }
      
      // Initialize style transfer tab functionality
      function setupStyleTransferTab() {
        if (intensitySlider && intensityValue) {
          intensitySlider.addEventListener('input', () => {
            const value = Math.round(intensitySlider.value * 100);
            intensityValue.textContent = `${value}%`;
          });
        }
      }
      
      // Mask editor functionality
      function initMaskEditor() {
        const canvas = document.getElementById('maskCanvas');
        const img = document.getElementById('maskBaseImage');
        const overlay = document.getElementById('maskOverlay');
        
        if (!img || !img.src || !canvas) return;
        
        // Set canvas dimensions to match image
        const rect = img.getBoundingClientRect();
        const canvasWidth = Math.min(rect.width, 1000);
        const canvasHeight = Math.min(rect.height, 1000);
        
        canvas.width = canvasWidth;
        canvas.height = canvasHeight;
        canvas.style.width = '100%';
        canvas.style.height = '100%';
        
        maskCanvas = canvas;
        maskCtx = canvas.getContext('2d');
        
        // Clear canvas
        maskCtx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Set up drawing tools
        setupDrawingTools();
        
        // Initialize overlay
        if (overlay) {
          overlay.style.width = '100%';
          overlay.style.height = '100%';
          overlay.style.position = 'absolute';
          overlay.style.top = '0';
          overlay.style.left = '0';
          overlay.style.pointerEvents = 'none';
          overlay.style.zIndex = '2';
        }
      }
      
      function setupDrawingTools() {
        if (!maskCanvas || !maskCtx) return;
        
        // Tool selection
        document.querySelectorAll('.mask-tool').forEach(tool => {
          tool.addEventListener('click', () => {
            document.querySelectorAll('.mask-tool').forEach(t => t.classList.remove('active'));
            tool.classList.add('active');
            currentTool = tool.getAttribute('data-tool');
          });
        });
        
        // Brush size
        const brushSizeInput = document.getElementById('brushSize');
        const brushPreview = document.querySelector('.brush-size-preview');
        
        if (brushSizeInput && brushPreview) {
          brushSizeInput.addEventListener('input', () => {
            brushSize = parseInt(brushSizeInput.value);
            brushPreview.style.width = `${brushSize/2}px`;
            brushPreview.style.height = `${brushSize/2}px`;
          });
        }
        
        // Drawing events
        maskCanvas.addEventListener('mousedown', startDrawing);
        maskCanvas.addEventListener('mousemove', draw);
        maskCanvas.addEventListener('mouseup', stopDrawing);
        maskCanvas.addEventListener('mouseleave', stopDrawing);
        
        maskCanvas.addEventListener('touchstart', (e) => {
          e.preventDefault();
          startDrawing({ clientX: e.touches[0].clientX, clientY: e.touches[0].clientY });
        });
        maskCanvas.addEventListener('touchmove', (e) => {
          e.preventDefault();
          draw({ clientX: e.touches[0].clientX, clientY: e.touches[0].clientY });
        });
        maskCanvas.addEventListener('touchend', stopDrawing);
        
        // Undo/Redo
        const undoTool = document.querySelector('[data-tool="undo"]');
        const redoTool = document.querySelector('[data-tool="redo"]');
        
        if (undoTool) {
          undoTool.addEventListener('click', undo);
        }
        
        if (redoTool) {
          redoTool.addEventListener('click', redo);
        }
      }
      
      function startDrawing(e) {
        if (!maskCanvas || !maskCtx) return;
        
        isDrawing = true;
        saveState();
        draw(e);
      }
      
      function draw(e) {
        if (!isDrawing || !maskCanvas || !maskCtx) return;
        
        const rect = maskCanvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        
        maskCtx.beginPath();
        
        if (currentTool === 'brush') {
          // Blue for keep areas
          maskCtx.globalCompositeOperation = 'source-over';
          maskCtx.strokeStyle = 'rgba(0, 0, 255, 0.5)';
        } else if (currentTool === 'eraser') {
          // Red for remove areas (with transparency)
          maskCtx.globalCompositeOperation = 'source-over';
          maskCtx.strokeStyle = 'rgba(255, 0, 0, 0.5)';
        } else if (currentTool === 'fill') {
          // Fill implementation would go here
          return;
        }
        
        maskCtx.lineWidth = brushSize;
        maskCtx.lineCap = 'round';
        maskCtx.lineTo(x, y);
        maskCtx.stroke();
        maskCtx.beginPath();
        maskCtx.moveTo(x, y);
      }
      
      function stopDrawing() {
        isDrawing = false;
        if (maskCtx) {
          maskCtx.beginPath();
        }
      }
      
      function saveState() {
        if (!maskCtx || !maskCanvas) return;
        
        // Save current state to history
        maskHistory = maskHistory.slice(0, historyIndex + 1);
        maskHistory.push(maskCtx.getImageData(0, 0, maskCanvas.width, maskCanvas.height));
        historyIndex = maskHistory.length - 1;
      }
      
      function undo() {
        if (historyIndex <= 0 || !maskCtx) return;
        
        historyIndex--;
        maskCtx.putImageData(maskHistory[historyIndex], 0, 0);
      }
      
      function redo() {
        if (historyIndex >= maskHistory.length - 1 || !maskCtx) return;
        
        historyIndex++;
        maskCtx.putImageData(maskHistory[historyIndex], 0, 0);
      }
      
      // Function to get mask data as base64
      function getMaskData() {
        if (!maskCanvas || !maskCtx) return null;
        
        // Create a new canvas to process the mask
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = maskCanvas.width;
        tempCanvas.height = maskCanvas.height;
        const tempCtx = tempCanvas.getContext('2d');
        
        // Copy the mask data
        tempCtx.drawImage(maskCanvas, 0, 0);
        
        // Process the mask to make it more defined
        const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
        const data = imageData.data;
        
        // Convert to binary mask (keep areas = blue, remove areas = red)
        for (let i = 0; i < data.length; i += 4) {
          const r = data[i];
          const g = data[i+1];
          const b = data[i+2];
          const a = data[i+3];
          
          // If it's blue (keep area), make it fully opaque blue
          if (b > r && b > g && a > 50) {
            data[i] = 0;
            data[i+1] = 0;
            data[i+2] = 255;
            data[i+3] = 255;
          } 
          // If it's red (remove area), make it fully opaque red
          else if (r > g && r > b && a > 50) {
            data[i] = 255;
            data[i+1] = 0;
            data[i+2] = 0;
            data[i+3] = 255;
          }
          // Otherwise, make it transparent
          else {
            data[i+3] = 0;
          }
        }
        
        tempCtx.putImageData(imageData, 0, 0);
        
        // Return as base64
        return tempCanvas.toDataURL('image/png');
      }
      
      // === Toast Notification System ===
      function showToast(message) {
        if (!toast) return;
        toast.textContent = message;
        toast.classList.add('show');
        
        setTimeout(() => {
          toast.classList.remove('show');
        }, 3000);
      }

      // Detect Facebook WebView
      function isFacebookWebView() {
        const ua = navigator.userAgent || navigator.vendor || window.opera;
        return (ua.indexOf("FBAN") > -1) || (ua.indexOf("FBAV") > -1) || 
               (ua.indexOf("FB_IAB") > -1) || (ua.indexOf("FB4A") > -1);
      }

      // Show Facebook warning if needed
      if (document.getElementById('fbWarning')) {
        if (isFacebookWebView()) {
          document.getElementById('fbWarning').style.display = 'block';
        }
      }

      // === Rest of the JS ===
      if (dropzone && imageInput) {
        // Prompt Edit Tab
        dropzone.addEventListener("click", () => imageInput.click());
        dropzone.addEventListener("dragover", (e) => {
          e.preventDefault();
          dropzone.classList.add("border-blue-500", "bg-blue-50");
        });
        dropzone.addEventListener("dragleave", () => {
          dropzone.classList.remove("border-blue-500", "bg-blue-50");
        });
        dropzone.addEventListener("drop", (e) => {
          e.preventDefault();
          dropzone.classList.remove("border-blue-500", "bg-blue-50");
          if (e.dataTransfer.files.length) {
            const file = e.dataTransfer.files[0];
            handleImageUpload(file, 'prompt');
          }
        });
        
        imageInput.addEventListener("change", () => {
          const file = imageInput.files[0];
          if (file) {
            handleImageUpload(file, 'prompt');
          }
        });
      }
      
      if (maskDropzone && maskImageInput) {
        // Mask Edit Tab
        maskDropzone.addEventListener("click", () => maskImageInput.click());
        maskDropzone.addEventListener("dragover", (e) => {
          e.preventDefault();
          maskDropzone.classList.add("border-blue-500", "bg-blue-50");
        });
        maskDropzone.addEventListener("dragleave", () => {
          maskDropzone.classList.remove("border-blue-500", "bg-blue-50");
        });
        maskDropzone.addEventListener("drop", (e) => {
          e.preventDefault();
          maskDropzone.classList.remove("border-blue-500", "bg-blue-50");
          if (e.dataTransfer.files.length) {
            const file = e.dataTransfer.files[0];
            handleImageUpload(file, 'mask');
          }
        });
        
        maskImageInput.addEventListener("change", () => {
          const file = maskImageInput.files[0];
          if (file) {
            handleImageUpload(file, 'mask');
          }
        });
      }
      
      if (styleDropzone && styleImageInput) {
        // Style Transfer Tab
        styleDropzone.addEventListener("click", () => styleImageInput.click());
        styleDropzone.addEventListener("dragover", (e) => {
          e.preventDefault();
          styleDropzone.classList.add("border-blue-500", "bg-blue-50");
        });
        styleDropzone.addEventListener("dragleave", () => {
          styleDropzone.classList.remove("border-blue-500", "bg-blue-50");
        });
        styleDropzone.addEventListener("drop", (e) => {
          e.preventDefault();
          styleDropzone.classList.remove("border-blue-500", "bg-blue-50");
          if (e.dataTransfer.files.length) {
            const file = e.dataTransfer.files[0];
            handleImageUpload(file, 'style');
          }
        });
        
        styleImageInput.addEventListener("change", () => {
          const file = styleImageInput.files[0];
          if (file) {
            handleImageUpload(file, 'style');
          }
        });
      }
      
      function showPreview(file, type) {
        const reader = new FileReader();
        reader.onload = () => {
          if (type === 'prompt' && imagePreview && previewImg && previewName && previewSize) {
            previewImg.src = reader.result;
            previewName.textContent = file.name;
            previewSize.textContent = (file.size / (1024*1024)).toFixed(1) + " MB";
            imagePreview.classList.remove("hidden");
          } else if (type === 'mask' && maskImagePreview && maskPreviewImg && maskPreviewName && maskPreviewSize) {
            maskPreviewImg.src = reader.result;
            maskPreviewName.textContent = file.name;
            maskPreviewSize.textContent = (file.size / (1024*1024)).toFixed(1) + " MB";
            maskImagePreview.classList.remove("hidden");
            
            // Show mask editor
            if (document.getElementById('maskEditor')) {
              document.getElementById('maskEditor').classList.remove('hidden');
              if (document.getElementById('maskBaseImage')) {
                document.getElementById('maskBaseImage').src = reader.result;
              }
            }
          } else if (type === 'style' && styleImagePreview && stylePreviewImg && stylePreviewName && stylePreviewSize) {
            stylePreviewImg.src = reader.result;
            stylePreviewName.textContent = file.name;
            stylePreviewSize.textContent = (file.size / (1024*1024)).toFixed(1) + " MB";
            styleImagePreview.classList.remove("hidden");
          }
        };
        reader.readAsDataURL(file);
      }

      function handleImageUpload(file, type) {
        // Check if file is an image
        if (!file.type.match('image.*')) {
          alert('Please select an image file (PNG, JPG, GIF)');
          return;
        }
        
        // Show preview with original size
        showPreview(file, type);
        
        // Store the original file for later processing
        if (type === 'prompt' && imageInput) {
          const dataTransfer = new DataTransfer();
          dataTransfer.items.add(file);
          imageInput.files = dataTransfer.files;
        } else if (type === 'mask' && maskImageInput) {
          const dataTransfer = new DataTransfer();
          dataTransfer.items.add(file);
          maskImageInput.files = dataTransfer.files;
        } else if (type === 'style' && styleImageInput) {
          const dataTransfer = new DataTransfer();
          dataTransfer.items.add(file);
          styleImageInput.files = dataTransfer.files;
        }
        
        showToast("Image uploaded successfully");
      }

      // === Vertical Reveal Slider (Mobile-Fixed) ===
      if (sliderHandle && imageOverlay && beforeImage && afterImage) {
        let isDragging = false;

        function handleMove(e) {
          if (!isDragging) return;
          
          e.preventDefault(); // Prevent scrolling while dragging
          
          const container = sliderHandle.parentElement;
          const rect = container.getBoundingClientRect();
          const clientX = e.clientX || (e.touches && e.touches[0].clientX);
          if (!clientX) return;
          
          let x = clientX - rect.left;
          const maxLeft = rect.width - 40;
          const clampedX = Math.max(0, Math.min(maxLeft, x));
          const percent = (clampedX / rect.width) * 100;
          
          sliderHandle.style.left = clampedX + 'px';
          imageOverlay.style.clipPath = `inset(0 ${100 - (clampedX / rect.width) * 100}% 0 0)`;
        }

        function stopDragging() {
          isDragging = false;
          document.removeEventListener('mousemove', handleMove);
          document.removeEventListener('mouseup', stopDragging);
          document.removeEventListener('touchmove', handleMove);
          document.removeEventListener('touchend', stopDragging);
        }

        sliderHandle.addEventListener('mousedown', (e) => {
          isDragging = true;
          document.addEventListener('mousemove', handleMove);
          document.addEventListener('mouseup', stopDragging);
          e.preventDefault();
        });

        sliderHandle.addEventListener('touchstart', (e) => {
          isDragging = true;
          document.addEventListener('touchmove', handleMove, { passive: false });
          document.addEventListener('touchend', stopDragging);
          e.preventDefault();
        });
      }

      // === Style Presets ===
      function updatePlaceholder() {
        if (currentTab === 'promptEdit' && promptInput) {
          if (promptInput.value) return;
          
          const activeStyles = Array.from(promptSelectedStyles);
          if (activeStyles.length === 0) {
            promptInput.placeholder = defaultPlaceholder;
          } else {
            promptInput.placeholder = stylePlaceholders[activeStyles[0]] || defaultPlaceholder;
          }
        } else if (currentTab === 'maskEdit' && maskPromptInput) {
          if (maskPromptInput.value) return;
          maskPromptInput.placeholder = "Remove the background";
        } else if (currentTab === 'styleTransfer' && promptInput) {
          if (promptInput.value) return;
          
          const activeStyles = Array.from(styleTransferSelectedStyles);
          if (activeStyles.length === 0) {
            promptInput.placeholder = defaultPlaceholder;
          } else {
            promptInput.placeholder = stylePlaceholders[activeStyles[0]] || defaultPlaceholder;
          }
        }
      }

      function toggleStyle(button, style, tab) {
        let selectedStyles;
        
        if (tab === 'promptEdit') {
          selectedStyles = promptSelectedStyles;
        } else if (tab === 'maskEdit') {
          selectedStyles = maskSelectedStyles;
        } else {
          selectedStyles = styleTransferSelectedStyles;
        }
        
        const isActive = button.classList.contains('style-active');
        if (isActive) {
          button.classList.remove('style-active');
          button.style.backgroundColor = '';
          button.style.borderColor = 'var(--border-primary)';
          button.style.color = 'var(--text-primary)';
          selectedStyles.delete(style);
        } else {
          button.classList.add('style-active');
          button.style.backgroundColor = '#2563eb';
          button.style.borderColor = '#2563eb';
          button.style.color = 'white';
          selectedStyles.add(style);
        }
        
        updatePlaceholder();
      }

      if (promptInput) {
        promptInput.addEventListener('focus', () => {
          if (promptInput && !promptInput.value) {
            const activeStyles = Array.from(promptSelectedStyles);
            if (activeStyles.length > 0) {
              promptInput.placeholder = "For example: " + stylePlaceholders[activeStyles[0]];
            }
          }
        });

        promptInput.addEventListener('blur', () => {
          if (promptInput) {
            updatePlaceholder();
          }
        });
      }

      if (maskPromptInput) {
        maskPromptInput.addEventListener('focus', () => {
          if (maskPromptInput && !maskPromptInput.value) {
            maskPromptInput.placeholder = "Describe what to add/remove";
          }
        });

        maskPromptInput.addEventListener('blur', () => {
          if (maskPromptInput && !maskPromptInput.value) {
            maskPromptInput.placeholder = "Remove the background";
          }
        });
      }

      if (promptInput) {
        promptInput.addEventListener('focus', () => {
          if (promptInput && !promptInput.value) {
            const activeStyles = Array.from(styleTransferSelectedStyles);
            if (activeStyles.length > 0) {
              promptInput.placeholder = "For example: " + stylePlaceholders[activeStyles[0]];
            }
          }
        });

        promptInput.addEventListener('blur', () => {
          if (promptInput) {
            updatePlaceholder();
          }
        });
      }

      // === Loading Screen Animation ===
      let currentStage = 0;
      let loadingInterval;
      
      function startLoadingAnimation() {
        currentStage = 0;
        updateLoadingStage(currentStage);
        
        // Stage progression every 1.5s
        loadingInterval = setInterval(() => {
          if (currentStage < loadingStages.length - 1) {
            currentStage++;
            updateLoadingStage(currentStage);
          }
        }, 1500);
      }

      function updateLoadingStage(stageIndex) {
        if (loadingText) {
          loadingText.textContent = loadingStages[stageIndex].text;
        }
        
        // Update stage indicators
        stages.forEach((stage, i) => {
          if (stage && i <= stageIndex) {
            stage.classList.add('active');
          } else if (stage) {
            stage.classList.remove('active');
          }
        });
      }

      function stopLoadingAnimation() {
        clearInterval(loadingInterval);
        // Reset to first stage for next time
        updateLoadingStage(0);
      }

      // === Processing Functions ===
      function getStylePrompt(tab) {
        const styles = {
          anime: "in anime style",
          'studio ghibli': "in Studio Ghibli style",
          picasso: "in Picasso's cubist style, abstract forms",
          cyberpunk: "with cyberpunk neon lighting",
          'van gogh': "in the style of Van Gogh, expressive brushstrokes",
          lego: "as a LEGO diorama, plastic texture",
          'pixel art': "in 16-bit pixel art style",
          sketch: "as a pencil sketch, hand-drawn lines",
          pixar: "in Pixar 3D animation style, soft lighting",
          'desert mirage': "with desert mirage effect, heat haze"
        };
        
        let selectedStyles;
        
        if (tab === 'promptEdit') {
          selectedStyles = promptSelectedStyles;
        } else if (tab === 'maskEdit') {
          selectedStyles = maskSelectedStyles;
        } else {
          selectedStyles = styleTransferSelectedStyles;
        }
        
        return Array.from(selectedStyles)
          .map(s => styles[s] || s)
          .join(", ");
      }

      function fileToBase64(file) {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onload = () => {
            // Remove the data URL prefix (e.g., "image/png;base64,")
            const base64 = reader.result.split(',')[1];
            resolve(base64);
          };
          reader.onerror = reject;
          reader.readAsDataURL(file);
        });
      }

      // Smart compression function
      async function compressForServer(file) {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onload = function(e) {
            const img = new Image();
            img.src = e.target.result;
            
            img.onload = function() {
              let width = img.width;
              let height = img.height;
              
              // Calculate aspect ratio
              const aspectRatio = width / height;
              
              // Maximum dimensions for good quality
              const maxDimension = 1920;
              
              // Scale down if needed, but maintain aspect ratio
              if (width > maxDimension || height > maxDimension) {
                if (width > height) {
                  width = maxDimension;
                  height = Math.round(width / aspectRatio);
                } else {
                  height = maxDimension;
                  width = Math.round(height * aspectRatio);
                }
              }
              
              // Create canvas and draw image
              const canvas = document.createElement('canvas');
              canvas.width = width;
              canvas.height = height;
              const ctx = canvas.getContext('2d');
              ctx.drawImage(img, 0, 0, width, height);
              
              // Start with high quality
              let quality = 0.9;
              const mime = file.type || 'image/jpeg';
              
              function tryCompression() {
                // Convert to blob with current quality
                canvas.toBlob(blob => {
                  if (!blob) {
                    reject(new Error('Canvas toBlob failed'));
                    return;
                  }
                  
                  // Calculate expected base64 size (rough estimate)
                  const base64Size = blob.size * 1.33; // Base64 adds ~33% overhead
                  
                  // For Facebook WebView, be more conservative
                  const maxSize = isFacebookWebView() ? 3.0 * 1024 * 1024 : 3.5 * 1024 * 1024;
                  
                  // Check if size is acceptable
                  if (base64Size <= maxSize || quality <= 0.3) {
                    const compressedFile = new File([blob], file.name, {
                      type: file.type,
                      lastModified: file.lastModified
                    });
                    
                    resolve({
                      file: compressedFile,
                      originalSize: file.size,
                      compressedSize: blob.size,
                      quality: quality,
                      dimensions: `${width}x${height}`
                    });
                  } else {
                    // Reduce quality and try again
                    quality -= 0.1;
                    tryCompression();
                  }
                }, mime, quality);
              }
              
              tryCompression();
            };
            
            img.onerror = function() {
              reject(new Error('Image load error'));
            };
          };
          
          reader.onerror = function() {
            reject(new Error('File reader error'));
          };
          
          reader.readAsDataURL(file);
        });
      }

      // === API Functions ===
      // === Dark Mode Toggle ===
      const darkModeToggle = document.getElementById('darkModeToggle');
      const body = document.body;

      const prefersDark = localStorage.getItem('kamuy_dark_mode') === 'true';
      if (prefersDark) {
        body.classList.add('dark');
        darkModeToggle.textContent = 'Light Mode';
      }

      if (darkModeToggle) {
        darkModeToggle.addEventListener('click', () => {
          body.classList.toggle('dark');
          if (body.classList.contains('dark')) {
            darkModeToggle.textContent = 'Light Mode';
            localStorage.setItem('kamuy_dark_mode', 'true');
          } else {
            darkModeToggle.textContent = 'Dark Mode';
            localStorage.setItem('kamuy_dark_mode', 'false');
          }
        });
      }

      // === History Panel ===
      const historyPanel = document.getElementById('historyPanel');
      const openHistory = document.getElementById('openHistory');
      const closeHistory = document.getElementById('closeHistory');
      const historyList = document.getElementById('historyList');

      if (openHistory) {
        openHistory.addEventListener('click', () => {
          historyPanel.classList.add('open');
        });
      }

      if (closeHistory) {
        closeHistory.addEventListener('click', () => {
          historyPanel.classList.remove('open');
        });
      }

      // Load history from localStorage
      function loadHistory() {
        const history = JSON.parse(localStorage.getItem('kamuy_edit_history') || '[]');
        if (!historyList) return;
        historyList.innerHTML = '';
        if (history.length === 0) {
          historyList.innerHTML = '<p class="text-sm text-gray-500">No edits yet</p>';
        }
        history.forEach((item, index) => {
          const div = document.createElement('div');
          div.className = 'history-item';
          div.innerHTML = `
            <img src="${item.thumbnail}" alt="Edit" />
            <div class="history-prompt">${item.prompt}</div>
            <small class="text-xs text-gray-500">${new Date(item.date).toLocaleString()}</small>
          `;
          div.onclick = () => {
            beforeImage.src = item.original;
            afterImage.src = item.edited;
            resultDiv.classList.remove('hidden');
            historyPanel.classList.remove('open');
            showToast("Loaded from history!");
          };
          historyList.appendChild(div);
        });
      }

      // Save to history
      function saveToHistory(original, edited, prompt) {
        const history = JSON.parse(localStorage.getItem('kamuy_edit_history') || '[]');
        const canvas = document.createElement('canvas');
        const img = new Image();
        img.onload = () => {
          canvas.width = 100;
          canvas.height = 100;
          const ctx = canvas.getContext('2d');
          ctx.drawImage(img, 0, 0, 100, 100);
          const thumbnail = canvas.toDataURL('image/jpeg', 0.7);

          const newItem = {
            original,
            edited,
            thumbnail,
            prompt,
            date: new Date().toISOString()
          };
          history.unshift(newItem);
          // Keep only last 5
          localStorage.setItem('kamuy_edit_history', JSON.stringify(history.slice(0, 5)));
          loadHistory();
        };
        img.src = edited;
      }

      // Initialize history
      loadHistory();

      // === Prompt Edit Functionality ===
      if (editBtn) {
        editBtn.addEventListener("click", async () => {
          const imageFile = imageInput.files[0];
          const prompt = promptInput.value.trim();
          const stylePrompt = getStylePrompt('promptEdit');

          if (!imageFile || (!prompt && promptSelectedStyles.size === 0)) {
            alert("Please upload an image and enter a prompt or select a style.");
            return;
          }

          try {
            editBtn.classList.add("hidden");
            if (loading) loading.classList.remove("hidden");
            if (resultDiv) resultDiv.classList.add("hidden");
            
            // Start loading animation
            startLoadingAnimation();
            
            const finalPrompt = stylePrompt ? (prompt ? `${prompt}, ${stylePrompt}` : stylePrompt) : prompt;
            const compressionResult = await compressForServer(imageFile);
            const compressedFile = compressionResult.file;
            
            // Show compression info
            const originalMB = (imageFile.size / (1024*1024)).toFixed(1);
            const compressedMB = (compressionResult.compressedSize / (1024*1024)).toFixed(1);
            const qualityMsg = `Optimized from ${originalMB}MB to ${compressedMB}MB (${compressionResult.dimensions})`;
            showToast(qualityMsg);

            // Convert to base64
            const base64Image = await fileToBase64(compressedFile);

            // API call
            const response = await fetch("/api/edit", {
              method: "POST",
              headers: { 
                "Content-Type": "application/json",
                "Accept": "application/json"
              },
              body: JSON.stringify({
                image: base64Image,
                imageName: imageFile.name,
                imageType: imageFile.type,
                prompt: finalPrompt
              })
            });

            // Stop loading animation
            stopLoadingAnimation();

            // Error handling
            if (!response.ok) {
              let errorMessage = `Server error: ${response.status}`;
              try {
                const errorData = await response.json();
                if (errorData.error) {
                  errorMessage += ` - ${errorData.error}`;
                } else if (errorData.detail) {
                  errorMessage += ` - ${errorData.detail}`;
                }
              } catch (e) {
                try {
                  const errorText = await response.text();
                  errorMessage += ` - ${errorText.substring(0, 100)}...`;
                } catch (e2) {
                  errorMessage += " - Failed to parse error response";
                }
              }
              
              // Special handling for Facebook WebView issues
              if (isFacebookWebView() && response.status === 413) {
                errorMessage = "Image too large for Facebook browser. Please open in Chrome or Safari and try again.";
              }
              
              throw new Error(errorMessage);
            }

            // Parse response
            const contentType = response.headers.get("content-type");
            let data;
            if (contentType && contentType.includes("application/json")) {
              data = await response.json();
            } else {
              throw new Error("Expected JSON response but received different content type");
            }

            if (data.edited_image_url) {
              const originalUrl = URL.createObjectURL(imageFile);
              beforeImage.src = originalUrl;
              afterImage.src = data.edited_image_url;
              
              if (resultDiv) resultDiv.classList.remove("hidden");

              // Reset slider to 50%
              const container = sliderHandle.parentElement;
              const midPoint = (container.offsetWidth - 40) / 2;
              sliderHandle.style.left = midPoint + 'px';
              imageOverlay.style.clipPath = 'inset(0 50% 0 0)';

              // Set up download functionality
              setupDownload(data.edited_image_url);
              showToast("Edit completed! 🎉");
            } else {
              throw new Error("Invalid response format: missing edited_image_url");
            }
          } catch (err) {
            console.error("Detailed error:", err);
            // Stop loading animation on error
            stopLoadingAnimation();
            if (loading) loading.classList.add("hidden");
            if (editBtn) editBtn.classList.remove("hidden");
            alert("Error: " + err.message + "\\n\\nPlease try a smaller image or open in Chrome/Safari browser.");
          }
        });
      }
      
      // === Mask Edit Functionality ===
      if (maskEditBtn) {
        maskEditBtn.addEventListener("click", async () => {
          const imageFile = maskImageInput.files[0];
          const prompt = document.getElementById("maskPrompt").value.trim();
          
          if (!imageFile || !prompt) {
            alert("Please upload an image and enter a prompt for the mask edit.");
            return;
          }
          
          try {
            maskEditBtn.classList.add("hidden");
            if (loading) loading.classList.remove("hidden");
            if (resultDiv) resultDiv.classList.add("hidden");
            
            // Start loading animation
            startLoadingAnimation();
            
            // For mask editing, we'll use the same compression as prompt editing
            const compressionResult = await compressForServer(imageFile);
            const compressedFile = compressionResult.file;
            
            // Show compression info
            const originalMB = (imageFile.size / (1024*1024)).toFixed(1);
            const compressedMB = (compressionResult.compressedSize / (1024*1024)).toFixed(1);
            const qualityMsg = `Optimized from ${originalMB}MB to ${compressedMB}MB (${compressionResult.dimensions})`;
            showToast(qualityMsg);

            // Convert to base64
            const base64Image = await fileToBase64(compressedFile);
            
            // Get mask data if available
            const maskData = getMaskData();

            // API call - same endpoint but with mask information
            const response = await fetch("/api/edit", {
              method: "POST",
              headers: { 
                "Content-Type": "application/json",
                "Accept": "application/json"
              },
              body: JSON.stringify({
                image: base64Image,
                imageName: imageFile.name,
                imageType: imageFile.type,
                prompt: prompt,
                // Include mask data
                mask: maskData
              })
            });

            // Stop loading animation
            stopLoadingAnimation();

            // Error handling
            if (!response.ok) {
              let errorMessage = `Server error: ${response.status}`;
              try {
                const errorData = await response.json();
                if (errorData.error) {
                  errorMessage += ` - ${errorData.error}`;
                } else if (errorData.detail) {
                  errorMessage += ` - ${errorData.detail}`;
                }
              } catch (e) {
                try {
                  const errorText = await response.text();
                  errorMessage += ` - ${errorText.substring(0, 100)}...`;
                } catch (e2) {
                  errorMessage += " - Failed to parse error response";
                }
              }
              
              throw new Error(errorMessage);
            }

            // Parse response
            const contentType = response.headers.get("content-type");
            let data;
            if (contentType && contentType.includes("application/json")) {
              data = await response.json();
            } else {
              throw new Error("Expected JSON response but received different content type");
            }

            if (data.edited_image_url) {
              const originalUrl = URL.createObjectURL(imageFile);
              beforeImage.src = originalUrl;
              afterImage.src = data.edited_image_url;
              
              if (resultDiv) resultDiv.classList.remove("hidden");

              // Reset slider to 50%
              const container = sliderHandle.parentElement;
              const midPoint = (container.offsetWidth - 40) / 2;
              sliderHandle.style.left = midPoint + 'px';
              imageOverlay.style.clipPath = 'inset(0 50% 0 0)';

              // Set up download functionality
              setupDownload(data.edited_image_url);
              showToast("Mask edit completed! 🎉");
            } else {
              throw new Error("Invalid response format: missing edited_image_url");
            }
          } catch (err) {
            console.error("Detailed error:", err);
            // Stop loading animation on error
            stopLoadingAnimation();
            if (loading) loading.classList.add("hidden");
            if (maskEditBtn) maskEditBtn.classList.remove("hidden");
            alert("Error: " + err.message + "\\n\\nPlease try a smaller image or open in Chrome/Safari browser.");
          }
        });
      }
      
      // === Style Transfer Functionality ===
      if (styleEditBtn) {
        styleEditBtn.addEventListener("click", async () => {
          const imageFile = styleImageInput.files[0];
          const prompt = promptInput.value.trim();
          const stylePrompt = getStylePrompt('styleTransfer');
          const intensity = intensitySlider ? intensitySlider.value : 0.7;
          
          if (!imageFile || styleTransferSelectedStyles.size === 0) {
            alert("Please upload an image and select at least one style.");
            return;
          }
          
          try {
            styleEditBtn.classList.add("hidden");
            if (loading) loading.classList.remove("hidden");
            if (resultDiv) resultDiv.classList.add("hidden");
            
            // Start loading animation
            startLoadingAnimation();
            
            // For style transfer, we'll use the same compression
            const compressionResult = await compressForServer(imageFile);
            const compressedFile = compressionResult.file;
            
            // Show compression info
            const originalMB = (imageFile.size / (1024*1024)).toFixed(1);
            const compressedMB = (compressionResult.compressedSize / (1024*1024)).toFixed(1);
            const qualityMsg = `Optimized from ${originalMB}MB to ${compressedMB}MB (${compressionResult.dimensions})`;
            showToast(qualityMsg);

            // Convert to base64
            const base64Image = await fileToBase64(compressedFile);

            // Construct prompt with style information
            let finalPrompt = stylePrompt;
            if (prompt) {
              finalPrompt = `${prompt}, ${stylePrompt}`;
            }
            
            // API call
            const response = await fetch("/api/edit", {
              method: "POST",
              headers: { 
                "Content-Type": "application/json",
                "Accept": "application/json"
              },
              body: JSON.stringify({
                image: base64Image,
                imageName: imageFile.name,
                imageType: imageFile.type,
                prompt: finalPrompt,
                // In a real implementation, we'd use intensity parameter
                style_intensity: intensity
              })
            });

            // Stop loading animation
            stopLoadingAnimation();

            // Error handling
            if (!response.ok) {
              let errorMessage = `Server error: ${response.status}`;
              try {
                const errorData = await response.json();
                if (errorData.error) {
                  errorMessage += ` - ${errorData.error}`;
                } else if (errorData.detail) {
                  errorMessage += ` - ${errorData.detail}`;
                }
              } catch (e) {
                try {
                  const errorText = await response.text();
                  errorMessage += ` - ${errorText.substring(0, 100)}...`;
                } catch (e2) {
                  errorMessage += " - Failed to parse error response";
                }
              }
              
              throw new Error(errorMessage);
            }

            // Parse response
            const contentType = response.headers.get("content-type");
            let data;
            if (contentType && contentType.includes("application/json")) {
              data = await response.json();
            } else {
              throw new Error("Expected JSON response but received different content type");
            }

            if (data.edited_image_url) {
              const originalUrl = URL.createObjectURL(imageFile);
              beforeImage.src = originalUrl;
              afterImage.src = data.edited_image_url;
              
              if (resultDiv) resultDiv.classList.remove("hidden");

              // Reset slider to 50%
              const container = sliderHandle.parentElement;
              const midPoint = (container.offsetWidth - 40) / 2;
              sliderHandle.style.left = midPoint + 'px';
              imageOverlay.style.clipPath = 'inset(0 50% 0 0)';

              // Set up download functionality
              setupDownload(data.edited_image_url);
              showToast("Style transfer completed! 🎨");
            } else {
              throw new Error("Invalid response format: missing edited_image_url");
            }
          } catch (err) {
            console.error("Detailed error:", err);
            // Stop loading animation on error
            stopLoadingAnimation();
            if (loading) loading.classList.add("hidden");
            if (styleEditBtn) styleEditBtn.classList.remove("hidden");
            alert("Error: " + err.message + "\\n\\nPlease try a smaller image or open in Chrome/Safari browser.");
          }
        });
      }

      // Setup download functionality with Facebook WebView compatibility
      function setupDownload(imageUrl) {
        // Clear previous instructions
        if (downloadInstructions) {
          downloadInstructions.textContent = '';
        }
        
        // For Facebook WebView, use a different approach
        if (isFacebookWebView()) {
          downloadBtn.onclick = async () => {
            try {
              // Fetch the image as blob
              const response = await fetch(imageUrl);
              const blob = await response.blob();
              
              // Create object URL
              const url = URL.createObjectURL(blob);
              
              // For mobile devices, open in new tab
              const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
              if (isMobile) {
                // Open in new window/tab
                window.open(url, '_blank');
                
                // Show instructions
                if (downloadInstructions) {
                  downloadInstructions.textContent = 'Tap and hold the image to save it to your device';
                }
                showToast('Image opened in new tab - tap and hold to save');
              } else {
                // For desktop Facebook WebView (rare), try normal download
                const a = document.createElement("a");
                a.href = url;
                a.download = "kamuy-edited.png";
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                showToast("Download started");
              }
            } catch (err) {
              alert("Download failed: " + err.message);
            }
          };
        } else {
          // Standard download for regular browsers
          downloadBtn.onclick = () => {
            fetch(imageUrl)
              .then(res => res.blob())
              .then(blob => {
                const url = URL.createObjectURL(blob);
                const a = document.createElement("a");
                a.href = url;
                a.download = "kamuy-edited.png";
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                showToast("Download started");
              })
              .catch(err => alert("Download failed: " + err.message));
          };
        }
      }

      // Initialize placeholder
      updatePlaceholder();
    });
  </script>
</body>
</html>
